{
    "beaker": "2",
    "evaluators": [
        {
            "name": "HTML",
            "plugin": "HTML",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "jsSetting2": "",
            "jsSetting1": "",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            }
        },
        {
            "name": "Java",
            "plugin": "Java",
            "imports": "com.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*\ncom.twosigma.beaker.chart.GradientColor\ncom.twosigma.beaker.chart.categoryplot.*\ncom.twosigma.beaker.chart.categoryplot.plotitem.*\ncom.twosigma.beaker.chart.histogram.*\ncom.twosigma.beaker.chart.treemap.*\ncom.twosigma.beaker.chart.treemap.util.*\nnet.sf.jtreemap.swing.*\ncom.twosigma.beaker.chart.heatmap.HeatMap\ncom.twosigma.beaker.jvm.object.*",
            "view": {
                "cm": {
                    "mode": "text/x-java"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "sectionkSa6qT",
            "type": "section",
            "title": "Testing with 479d4f8",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": false,
            "initialization": true
        },
        {
            "id": "codej39xAg",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.io.File;",
                    "import java.io.FileNotFoundException;",
                    "import java.text.SimpleDateFormat;",
                    "import java.util.*;",
                    "",
                    "/**",
                    " * A utilities class containing various static methods that may be of use",
                    " * in other classes, particularly in making large test cases.",
                    " * ",
                    " * @author CS125-Research",
                    " *",
                    " */",
                    "public class Utilities {",
                    "\t",
                    "\tpublic static Random gen = new Random();",
                    "\t",
                    "\t@SuppressWarnings(\"rawtypes\")",
                    "\tpublic static final Comparator<Comparable> naturalOrder = ",
                    "\t    new Comparator<Comparable>()",
                    "\t{",
                    "\t\t@SuppressWarnings(\"unchecked\")",
                    "\t\tpublic int compare(Comparable first, Comparable second){",
                    "\t\t\treturn first.compareTo(second);",
                    "\t\t}",
                    "\t};",
                    "\t",
                    "\t/**",
                    "\t * Takes an ArrayList of Strings, sorts it in alphabetical order, and",
                    "\t * returns an ArrayList with the same elements as the argument but",
                    "\t * without any duplicate elements.",
                    "\t * ",
                    "\t * @param words The words",
                    "\t * @return",
                    "\t */",
                    "\tprivate static ArrayList<String> filterDuplicates(ArrayList<String> words){",
                    "\t\tArrayList<String> results = new ArrayList<>();",
                    "\t\tString last = \"\";",
                    "\t\tCollections.sort(words);",
                    "\t\tfor (String elem : words){",
                    "\t\t\tif (!elem.equals(last))",
                    "\t\t\t\tresults.add(elem);",
                    "\t\t\tlast = elem;",
                    "\t\t}",
                    "\t\treturn results;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Generates a random integer from a geometric distribution with success",
                    "\t * probability p.",
                    "\t * ",
                    "\t * @param p Probability of success at a given trial, in the interval [0,1].",
                    "\t * @return The number of trials needed for a success.",
                    "\t */",
                    "\tprivate static int randomGeometric(double p){",
                    "\t\tint out = 1;",
                    "\t\twhile (Math.random() > p)",
                    "\t\t\t++out;",
                    "\t\treturn out;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Creates a random \"sentence\" of specified length from a set of",
                    "\t * \"words\" in a dictionary.",
                    "\t * ",
                    "\t * @param dict   The set of all words that can be used in the sentence.",
                    "\t * @param length The length of the target sentence.",
                    "\t * @return A random sentence whose words are all found in dictionary.",
                    "\t */",
                    "\tprivate static String randomSentence(ArrayList<String> dict, int length){",
                    "\t\tStringBuilder b = new StringBuilder();",
                    "\t\tint size = dict.size();",
                    "\t\tif (size == 0)",
                    "\t\t\treturn \"\";",
                    "\t\twhile (length-- > 0){",
                    "\t\t\tint randIdx = gen.nextInt(size);",
                    "\t\t\tb.append(dict.get(randIdx));",
                    "\t\t\tif (length != 0)",
                    "\t\t\t\tb.append(' ');",
                    "\t\t}",
                    "\t\treturn b.toString();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Creates fake roster information (all \"netID\"s are strings of six",
                    "\t * lowercase alphabets followed by a digit).",
                    "\t * ",
                    "\t * @param number The number of students in this fake roster.",
                    "\t * @return An ArrayList filled with random netIDs.",
                    "\t */",
                    "\tpublic static ArrayList<String> generateRoster(int number){",
                    "\t\tArrayList<String> netIDs = new ArrayList<>();",
                    "\t\twhile(netIDs.size() < number){",
                    "\t\t\twhile(netIDs.size() < number){",
                    "\t\t\t\tStringBuilder curr = new StringBuilder();",
                    "\t\t\t\tfor (int i = 0; i < 6; ++i){",
                    "\t\t\t\t\tchar letter = (char) ('a' + gen.nextInt(25));",
                    "\t\t\t\t\tcurr.append(letter);",
                    "\t\t\t\t}",
                    "\t\t\t\tchar digit = (char) ('0' + gen.nextInt(9));",
                    "\t\t\t\tcurr.append(digit);",
                    "\t\t\t\tnetIDs.add(curr.toString());",
                    "\t\t\t}",
                    "\t\t\tnetIDs = filterDuplicates(netIDs);",
                    "\t\t}",
                    "\t\treturn netIDs;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * This method generates an ArrayList of Strings based off of various input",
                    "\t * parameters. These Strings are meant to simulate real feedback",
                    "\t * using random generators. The method is designed to somewhat",
                    "\t * simulate real data by partitioning the data into several time intervals,",
                    "\t * each corresponding to a particular lecture (though these time intervals",
                    "\t * are all the same size). During these each interval, few students will",
                    "\t * give feedback more than once. However, not all students will leave",
                    "\t * feedback. A double array will be passed in to specify the desired",
                    "\t * probabilities of various events. A String array is used to generate",
                    "\t * random sentences for the PeerInteraction strengths and weaknesses",
                    "\t * parameters.",
                    "\t *  ",
                    "\t * @param lectures The number of \"lectures\" from the start to end date",
                    "\t * @param start    The date of the first lecture.",
                    "\t * @param stop     A date after the last lecture.",
                    "\t * @param netIDs   A list of all netIDs in the roster.",
                    "\t * @param dict     A list of words to be used in generating feedback.",
                    "\t * @param config   A double array of size 6 whose elements are all in the",
                    "\t *                 range [0,1] that specifies the probabilities of various",
                    "\t *                 events.",
                    "\t * @return",
                    "\t */",
                    "\tpublic static ArrayList<String> ",
                    "\t    generateFeedback(int lectures, Date start, Date stop, ",
                    "\t\t\t             ArrayList<String> netIDs, ArrayList<String> dict,",
                    "\t\t\t             double[] config)",
                    "\t{",
                    "\t\tSimpleDateFormat form = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");",
                    "\t\tlong range = stop.getTime() - start.getTime();",
                    "\t\tlong interval = range/lectures;",
                    "\t\t//config = {ATTENDANCE, VALID_PARTNER, HAS_FEEDBACK, ",
                    "\t\t//          STRENGTH_P_VAL, WEAKNESS_P_VAL, DUPLICATE};",
                    "\t\tlong currentTime = start.getTime();",
                    "\t\tint numStudents = netIDs.size();",
                    "\t\tArrayList<String> products = new ArrayList<>();",
                    "\t\twhile (lectures-- > 0){",
                    "\t\t\t//Forgive this monstrosity. Excessive indentation makes me cry.",
                    "\t\t\tfor (String person : netIDs) if (Math.random() < config[0]) do{",
                    "\t\t\t\tlong time = currentTime + (long) (Math.random()*interval);",
                    "\t\t\t\tString date = form.format(new Date(time));",
                    "\t\t\t\tString partner = Math.random() < config[1] ?",
                    "\t\t\t\t\t\tnetIDs.get(gen.nextInt(numStudents)) :",
                    "\t\t\t\t\t\t\"null\";",
                    "\t\t\t\tint rating = 1 + gen.nextInt(10);",
                    "\t\t\t\tboolean writeResponse = Math.random() < config[2];",
                    "\t\t\t\tString strength = writeResponse ?",
                    "\t\t\t\t\trandomSentence(dict, randomGeometric(config[3])) :",
                    "\t\t\t\t    \"\";",
                    "\t\t\t\tString weakness = writeResponse ?",
                    "\t\t\t\t\trandomSentence(dict, randomGeometric(config[4])) :",
                    "\t\t\t\t\t\"\";",
                    "\t\t\t\tString product = String.format(",
                    "\t\t\t\t    \"\\\"%s\\\", \\\"%s\\\", \\\"%d\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\"\",",
                    "\t\t\t\t    person, partner, rating, strength, weakness, date);",
                    "\t\t\t\tproducts.add(product);",
                    "\t\t\t}while(Math.random() < config[5]);",
                    "\t\t\tcurrentTime += interval;",
                    "\t\t}",
                    "\t\treturn products;",
                    "\t}",
                    "\t",
                    "\t",
                    "\t/**",
                    "\t * Takes in a collection of PeerInteraction objects and generates an",
                    "\t * ArrayList containing all the words used in strength and weakness fields",
                    "\t * of all elements of the collection. This is simply used to later generate",
                    "\t * fake PeerInteraction objects.",
                    "\t * ",
                    "\t * @param samples A collection of PeerInteractions ",
                    "\t * @return An ArrayList containing all distinct elements from the argument.",
                    "\t */",
                    "\tpublic static ArrayList<String> ",
                    "\t    dictFromInteractions(Iterable<PeerInteraction> samples)",
                    "\t{",
                    "\t\tArrayList<String> output = new ArrayList<>();",
                    "\t\tfor (PeerInteraction entry : samples)",
                    "\t\t\tif (entry.hasFeedback()){",
                    "\t\t\t\tString cat = entry.getStrength() + ' ' + entry.getWeakness();",
                    "\t\t\t\tScanner wordExtractor = new Scanner(cat);",
                    "\t\t\t\twhile (wordExtractor.hasNext())",
                    "\t\t\t\t\toutput.add(wordExtractor.next().replace(\"\\\"\", \"\\\"\\\"\"));",
                    "\t\t\t\twordExtractor.close();",
                    "\t\t\t}",
                    "\t\tCollections.sort(output);",
                    "\t\treturn output;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Simple main method that demonstrates the behavior of these test",
                    "\t * methods. It reads from the final CSV file of all PeerInteractions",
                    "\t * and constructs fake feedback using a randomly generated roster of",
                    "\t * students and randomly generates written feedback using words from",
                    "\t * the real FA2015 lecture feedback.",
                    "\t * ",
                    "\t * @param args Nothing",
                    "\t * @throws FileNotFoundException",
                    "\t */",
                    "\tpublic static void main(String[] args) throws FileNotFoundException{",
                    "\t\tfinal int LECTURES = 10;",
                    "\t\tfinal int STUDENTS = 100;",
                    "\t\tfinal int CAPACITY = 2*STUDENTS;",
                    "\t\tArrayList<String> fakeRoster = Utilities.generateRoster(STUDENTS);",
                    "\t\tArrayList<PeerInteraction> samples = new ArrayList<>();",
                    "\t\tScanner sc = ",
                    "\t\t    new Scanner(new File(\"src/peerInteractions.fa2015.final.csv\"));",
                    "\t\twhile (sc.hasNextLine()){",
                    "\t\t\tsamples.add(new PeerInteraction(sc.nextLine()));",
                    "\t\t}",
                    "\t\tArrayList<String> dictionary = Utilities.dictFromInteractions(samples);",
                    "\t\tNRList converter  = new NRList(fakeRoster, CAPACITY);",
                    "\t\t/*",
                    "\t\t * config[0]: The probability that a student will give feedback for a",
                    "\t\t *            particular lecture.",
                    "\t\t * config[1]: The probability that a student, given he gives feedback,",
                    "\t\t *            also gives a valid partner netID.",
                    "\t\t * config[2]: The probability that a student, given he gives",
                    "\t\t *            feedback, also gives strengths or weaknesses.",
                    "\t\t * config[3/4]: p-value for geometric distribution describing the length",
                    "\t\t *            of the student's strength/weakness response. The",
                    "\t\t *            expected response length is (1/config[4]).",
                    "\t\t * config[5]: The probability that a student will give a duplicate",
                    "\t\t *            entry. This is very small in practice.",
                    "\t\t */",
                    "\t\tdouble[] config = {0.667, 0.873, 0.15, 0.70, 0.40, 0.005};",
                    "\t\tDate now = new Date();",
                    "\t\tDate then = new Date(now.getTime() - 4*30*24*3600000l); //~4 months ago",
                    "\t\tArrayList<String> fakeRawFeedback = ",
                    "\t\t    Utilities.generateFeedback(LECTURES, then, now, ",
                    "\t\t    \t\t                  fakeRoster, dictionary, config);",
                    "\t\tNRList fakeNRList = new NRList(fakeRoster, fakeRoster.size()+300);",
                    "\t\tArrayList<PeerInteraction> fakeEntries = new ArrayList<>();",
                    "\t\tString last = \"\";",
                    "\t\tSystem.out.println(\"Dictionary: \\n\\n\");",
                    "\t\tfor (String elem : dictionary) if (!elem.equals(last)){",
                    "\t\t\tSystem.out.println(elem);",
                    "\t\t\tlast = elem;",
                    "\t\t}",
                    "\t\tSystem.out.println(\"\\n\\nFake Roster: \");",
                    "\t\tfor (String elem : fakeRoster)",
                    "\t\t\tSystem.out.println(elem);",
                    "\t\tSystem.out.println(\"\\n\\nFake Feedback: \");",
                    "\t\tint count = 0;",
                    "\t\tint validCount = 0;",
                    "\t\tint feedbackCount = 0;",
                    "\t\tfor (String elem : fakeRawFeedback){",
                    "\t\t\tPeerInteraction curr = new PeerInteraction(elem, fakeNRList);",
                    "\t\t\t++count;",
                    "\t\t\tif (curr.valid())",
                    "\t\t\t\t++validCount;",
                    "\t\t\tif (curr.hasFeedback())",
                    "\t\t\t\t++feedbackCount;",
                    "\t\t\tSystem.out.println(elem);",
                    "\t\t}",
                    "\t\tSystem.out.printf(\"\\n\\\"Attendance\\\": %.2f%% (Doesn't take into \"",
                    "\t\t    + \"account duplicates, so expect this to be higher than the \"",
                    "\t\t    + \"config parameter)\\n\", (100.0*count)/(LECTURES*STUDENTS));",
                    "\t\tSystem.out.printf(\"Validity: %.2f%%\\n\", (100.0*validCount)/count);",
                    "\t\tSystem.out.printf(\"Responsiveness: %.2f%%\\n\", ",
                    "\t\t                  (100.0*feedbackCount)/count);",
                    "\t}",
                    "\t",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 270
        },
        {
            "id": "codeO7Sfcp",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "//UIUC CS125 FALL 2014 MP. File: TextIO.java, CS125 Project: Challenge2-Hollywood, Version: 2015-09-14T14:18:04-0500.774664624",
                    "import java.io.BufferedReader;",
                    "import java.io.File;",
                    "import java.io.FileReader;",
                    "import java.io.FileWriter;",
                    "import java.io.InputStream;",
                    "import java.io.InputStreamReader;",
                    "import java.io.OutputStream;",
                    "import java.io.PrintWriter;",
                    "import java.io.Reader;",
                    "import java.util.IllegalFormatException;",
                    "import java.util.regex.Matcher;",
                    "import java.util.regex.Pattern;",
                    "",
                    "import javax.swing.JFileChooser;",
                    "import javax.swing.JOptionPane;",
                    "// FA12 Changes by L.Angrave: Some methods unnecessary for the programming assignment have been made private",
                    "",
                    "/** Includes FA08 UIUC Additions by L.Angrave.",
                    " * Last Update: 9/11/2008 (Fixed some compiler warnings) ",
                    " */",
                    "",
                    "/**",
                    " * TextIO provides a set of static methods for reading and writing text. By",
                    " * default, it reads from standard input and writes to standard output, but it",
                    " * is possible to redirect the input and output to files or to other input and",
                    " * output streams. When the standard input and output streams are being used,",
                    " * the input methods will not produce an error; instead, the user is repeatedly",
                    " * prompted for input until a legal input is entered. (If standard input has",
                    " * been changed externally, as by file redirection on the command line, this is",
                    " * not a reasonable behavior; to handle this case, TextIO will give up after 10",
                    " * consecutive illegal inputs and will throw an IllegalArgumentException.) For",
                    " * the most part, any other error will be translated into an",
                    " * IllegalArguementException.",
                    " * <p>",
                    " * For writing to standard output, the output methods in this class pretty much",
                    " * duplicate the functionality of System.out, and System.out can be used",
                    " * interchangeably with them.",
                    " * <p>",
                    " * This class does not use optimal Java programming practices. It is designed",
                    " * specifically to be easily usable even by a beginning programmer who has not",
                    " * yet learned about objects and exceptions. Therefore, everything is in a",
                    " * single source file that compiles into a single class file, all the methods",
                    " * are static methods, and none of the methods throw exceptions that would",
                    " * require try...catch statements. Also for this reason, all exceptions are",
                    " * converted into IllegalArgumentExceptions, even when this exception type",
                    " * doesn't really make sense.",
                    " * <p>",
                    " * This class requires Java 5.0 or higher. (A previous version of TextIO",
                    " * required only Java 1.1; this version should work with any source code that",
                    " * used the previous version, but it has some new features, including the type",
                    " * of formatted output that was introduced in Java 5 and the ability to use",
                    " * files and streams.",
                    " */",
                    "public class TextIO {",
                    "",
                    "\t/**",
                    "\t * The value returned by the peek() method when the input is at end-of-file.",
                    "\t * (The value of this constant is (char)0xFFFF.)",
                    "\t */",
                    "\tpublic final static char EOF = (char) 0xFFFF;",
                    "",
                    "\t/**",
                    "\t * The value returned by the peek() method when the input is at end-of-line.",
                    "\t * The value of this constant is the character '\\n'.",
                    "\t */",
                    "\tpublic final static char EOLN = '\\n'; // The value returned by",
                    "",
                    "\t// peek() when at",
                    "\t// end-of-line.",
                    "",
                    "\t/**",
                    "\t * After this method is called, input will be read from standard input (as",
                    "\t * it is in the default state). If a file or stream was previously the input",
                    "\t * source, that file or stream is closed.",
                    "\t */",
                    "\tpublic static void readStandardInput() {",
                    "\t\tif (readingStandardInput)",
                    "\t\t\treturn;",
                    "\t\ttry {",
                    "\t\t\tin.close();",
                    "\t\t} catch (Exception e) {/*Ignored*/",
                    "\t\t}",
                    "\t\tin = standardInput;",
                    "\t\tinputFileName = null;",
                    "\t\treadingStandardInput = true;",
                    "\t\tinputErrorCount = 0;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * After this method is called, input will be read from inputStream,",
                    "\t * provided it is non-null. If inputStream is null, then this method has the",
                    "\t * same effect as calling readStandardInput(); that is, future input will",
                    "\t * come from the standard input stream.",
                    "\t */",
                    "\tpublic static void readStream(InputStream inputStream) {",
                    "\t\tif (inputStream == null)",
                    "\t\t\treadStandardInput();",
                    "\t\telse {",
                    "\t\t\treadStream(new InputStreamReader(inputStream));",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * After this method is called, input will be read from inputStream,",
                    "\t * provided it is non-null. If inputStream is null, then this method has the",
                    "\t * same effect as calling readStandardInput(); that is, future input will",
                    "\t * come from the standard input stream.",
                    "\t */",
                    "\tpublic static void readStream(Reader inputStream) {",
                    "\t\tif (inputStream == null)",
                    "\t\t\treadStandardInput();",
                    "\t\telse {",
                    "\t\t\tif (inputStream instanceof BufferedReader)",
                    "\t\t\t\tin = (BufferedReader) inputStream;",
                    "\t\t\telse",
                    "\t\t\t\tin = new BufferedReader(inputStream);",
                    "\t\t\tinputFileName = null;",
                    "\t\t\treadingStandardInput = false;",
                    "\t\t\tinputErrorCount = 0;",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Opens a file with a specified name for input. If the file name is null,",
                    "\t * this has the same effect as calling readStandardInput(); that is, input",
                    "\t * will be read from standard input. If an error occurs while trying to open",
                    "\t * the file, an exception of type IllegalArgumentException is thrown, and",
                    "\t * the input source is not changed. If the file is opened successfully, then",
                    "\t * after this method is called, all of the input routines will read from the",
                    "\t * file, instead of from standard input.",
                    "\t */",
                    "\tpublic static void readFile(String fileName) {",
                    "\t\tif (fileName == null) // Go back to reading standard input",
                    "\t\t\treadStandardInput();",
                    "\t\telse {",
                    "\t\t\tBufferedReader newin;",
                    "\t\t\ttry {",
                    "\t\t\t\tnewin = new BufferedReader(new FileReader(fileName));",
                    "\t\t\t} catch (Exception e) {",
                    "\t\t\t\tthrow new IllegalArgumentException(\"Can't open file \\\"\"",
                    "\t\t\t\t\t\t+ fileName + \"\\\" for input.\\n\" + \"(Error :\" + e + \")\");",
                    "\t\t\t}",
                    "\t\t\tif (!readingStandardInput) { // close current input stream",
                    "\t\t\t\ttry {",
                    "\t\t\t\t\tin.close();",
                    "\t\t\t\t} catch (Exception e) {/*Ignored*/",
                    "\t\t\t\t}",
                    "\t\t\t}",
                    "\t\t\tin = newin;",
                    "\t\t\treadingStandardInput = false;",
                    "\t\t\tinputErrorCount = 0;",
                    "\t\t\tinputFileName = fileName;",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Puts a GUI file-selection dialog box on the screen in which the user can",
                    "\t * select an input file. If the user cancels the dialog instead of selecting",
                    "\t * a file, it is not considered an error, but the return value of the",
                    "\t * subroutine is false. If the user does select a file, but there is an",
                    "\t * error while trying to open the file, then an exception of type",
                    "\t * IllegalArgumentException is thrown. Finally, if the user selects a file",
                    "\t * and it is successfully opened, then the return value of the subroutine is",
                    "\t * true, and the input routines will read from the file, instead of from",
                    "\t * standard input. If the user cancels, or if any error occurs, then the",
                    "\t * previous input source is not changed.",
                    "\t * <p>",
                    "\t * NOTE: Calling this method starts a GUI user interface thread, which can",
                    "\t * continue to run even if the thread that runs the main program ends. If",
                    "\t * you use this method in a non-GUI program, it might be necessary to call",
                    "\t * System.exit(0) at the end of the main() routine to shut down the Java",
                    "\t * virtual machine completely.",
                    "\t */",
                    "\tpublic static boolean readUserSelectedFile() {",
                    "\t\tif (fileDialog == null)",
                    "\t\t\tfileDialog = new JFileChooser();",
                    "\t\tfileDialog.setDialogTitle(\"Select File for Input\");",
                    "\t\tint option = fileDialog.showOpenDialog(null);",
                    "\t\tif (option != JFileChooser.APPROVE_OPTION)",
                    "\t\t\treturn false;",
                    "\t\tFile selectedFile = fileDialog.getSelectedFile();",
                    "\t\tBufferedReader newin;",
                    "\t\ttry {",
                    "\t\t\tnewin = new BufferedReader(new FileReader(selectedFile));",
                    "\t\t} catch (Exception e) {",
                    "\t\t\tthrow new IllegalArgumentException(\"Can't open file \\\"\"",
                    "\t\t\t\t\t+ selectedFile.getName() + \"\\\" for input.\\n\" + \"(Error :\"",
                    "\t\t\t\t\t+ e + \")\");",
                    "\t\t}",
                    "\t\tif (!readingStandardInput) { // close current file",
                    "\t\t\ttry {",
                    "\t\t\t\tin.close();",
                    "\t\t\t} catch (Exception e) {/*Ignored*/",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tin = newin;",
                    "\t\tinputFileName = selectedFile.getName();",
                    "\t\treadingStandardInput = false;",
                    "\t\tinputErrorCount = 0;",
                    "\t\treturn true;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * After this method is called, output will be written to standard output",
                    "\t * (as it is in the default state). If a file or stream was previously open",
                    "\t * for output, it will be closed.",
                    "\t */",
                    "\tpublic static void writeStandardOutput() {",
                    "\t\tif (writingStandardOutput)",
                    "\t\t\treturn;",
                    "\t\ttry {",
                    "\t\t\tout.close();",
                    "\t\t} catch (Exception e) {/*Ignored*/",
                    "\t\t}",
                    "\t\toutputFileName = null;",
                    "\t\toutputErrorCount = 0;",
                    "\t\tout = standardOutput;",
                    "\t\twritingStandardOutput = true;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * After this method is called, output will be sent to outputStream,",
                    "\t * provided it is non-null. If outputStream is null, then this method has",
                    "\t * the same effect as calling writeStandardOutput(); that is, future output",
                    "\t * will be sent to the standard output stream.",
                    "\t */",
                    "\tpublic static void writeStream(OutputStream outputStream) {",
                    "\t\tif (outputStream == null)",
                    "\t\t\twriteStandardOutput();",
                    "\t\telse",
                    "\t\t\twriteStream(new PrintWriter(outputStream));",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * After this method is called, output will be sent to outputStream,",
                    "\t * provided it is non-null. If outputStream is null, then this method has",
                    "\t * the same effect as calling writeStandardOutput(); that is, future output",
                    "\t * will be sent to the standard output stream.",
                    "\t */",
                    "\tpublic static void writeStream(PrintWriter outputStream) {",
                    "\t\tif (outputStream == null)",
                    "\t\t\twriteStandardOutput();",
                    "\t\telse {",
                    "\t\t\tout = outputStream;",
                    "\t\t\toutputFileName = null;",
                    "\t\t\toutputErrorCount = 0;",
                    "\t\t\twritingStandardOutput = false;",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Opens a file with a specified name for output. If the file name is null,",
                    "\t * this has the same effect as calling writeStandardOutput(); that is,",
                    "\t * output will be sent to standard output. If an error occurs while trying",
                    "\t * to open the file, an exception of type IllegalArgumentException is",
                    "\t * thrown. If the file is opened successfully, then after this method is",
                    "\t * called, all of the output routines will write to the file, instead of to",
                    "\t * standard output. If an error occurs, the output destination is not",
                    "\t * changed.",
                    "\t * <p>",
                    "\t * NOTE: Calling this method starts a GUI user interface thread, which can",
                    "\t * continue to run even if the thread that runs the main program ends. If",
                    "\t * you use this method in a non-GUI program, it might be necessary to call",
                    "\t * System.exit(0) at the end of the main() routine to shut down the Java",
                    "\t * virtual machine completely.",
                    "\t */",
                    "\tpublic static void writeFile(String fileName) {",
                    "\t\tif (fileName == null) // Go back to reading standard output",
                    "\t\t\twriteStandardOutput();",
                    "\t\telse {",
                    "\t\t\tPrintWriter newout;",
                    "\t\t\ttry {",
                    "\t\t\t\tnewout = new PrintWriter(new FileWriter(fileName));",
                    "\t\t\t} catch (Exception e) {",
                    "\t\t\t\tthrow new IllegalArgumentException(\"Can't open file \\\"\"",
                    "\t\t\t\t\t\t+ fileName + \"\\\" for output.\\n\" + \"(Error :\" + e + \")\");",
                    "\t\t\t}",
                    "\t\t\tif (!writingStandardOutput) {",
                    "\t\t\t\ttry {",
                    "\t\t\t\t\tout.close();",
                    "\t\t\t\t} catch (Exception e) {/*Ignored*/",
                    "\t\t\t\t}",
                    "\t\t\t}",
                    "\t\t\tout = newout;",
                    "\t\t\twritingStandardOutput = false;",
                    "\t\t\toutputFileName = fileName;",
                    "\t\t\toutputErrorCount = 0;",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Puts a GUI file-selection dialog box on the screen in which the user can",
                    "\t * select an output file. If the user cancels the dialog instead of",
                    "\t * selecting a file, it is not considered an error, but the return value of",
                    "\t * the subroutine is false. If the user does select a file, but there is an",
                    "\t * error while trying to open the file, then an exception of type",
                    "\t * IllegalArgumentException is thrown. Finally, if the user selects a file",
                    "\t * and it is successfully opened, then the return value of the subroutine is",
                    "\t * true, and the output routines will write to the file, instead of to",
                    "\t * standard output. If the user cancels, or if an error occurs, then the",
                    "\t * current output destination is not changed.",
                    "\t */",
                    "\tpublic static boolean writeUserSelectedFile() {",
                    "\t\tif (fileDialog == null)",
                    "\t\t\tfileDialog = new JFileChooser();",
                    "\t\tfileDialog.setDialogTitle(\"Select File for Output\");",
                    "\t\tFile selectedFile;",
                    "\t\twhile (true) {",
                    "\t\t\tint option = fileDialog.showSaveDialog(null);",
                    "\t\t\tif (option != JFileChooser.APPROVE_OPTION)",
                    "\t\t\t\treturn false; // user canceled",
                    "\t\t\tselectedFile = fileDialog.getSelectedFile();",
                    "\t\t\tif (selectedFile.exists()) {",
                    "\t\t\t\tint response = JOptionPane",
                    "\t\t\t\t\t\t.showConfirmDialog(",
                    "\t\t\t\t\t\t\t\tnull,",
                    "\t\t\t\t\t\t\t\t\"The file \\\"\"",
                    "\t\t\t\t\t\t\t\t\t\t+ selectedFile.getName()",
                    "\t\t\t\t\t\t\t\t\t\t+ \"\\\" already exists.  Do you want to replace it?\",",
                    "\t\t\t\t\t\t\t\t\"Replace existing file?\",",
                    "\t\t\t\t\t\t\t\tJOptionPane.YES_NO_OPTION,",
                    "\t\t\t\t\t\t\t\tJOptionPane.WARNING_MESSAGE);",
                    "\t\t\t\tif (response == JOptionPane.YES_OPTION)",
                    "\t\t\t\t\tbreak;",
                    "\t\t\t} else {",
                    "\t\t\t\tbreak;",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tPrintWriter newout;",
                    "\t\ttry {",
                    "\t\t\tnewout = new PrintWriter(new FileWriter(selectedFile));",
                    "\t\t} catch (Exception e) {",
                    "\t\t\tthrow new IllegalArgumentException(\"Can't open file \\\"\"",
                    "\t\t\t\t\t+ selectedFile.getName() + \"\\\" for output.\\n\" + \"(Error :\"",
                    "\t\t\t\t\t+ e + \")\");",
                    "\t\t}",
                    "\t\tif (!writingStandardOutput) {",
                    "\t\t\ttry {",
                    "\t\t\t\tout.close();",
                    "\t\t\t} catch (Exception e) {/*Ignored*/",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tout = newout;",
                    "\t\twritingStandardOutput = false;",
                    "\t\toutputFileName = selectedFile.getName();",
                    "\t\toutputErrorCount = 0;",
                    "\t\treturn true;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * If TextIO is currently reading from a file, then the return value is the",
                    "\t * name of the file. If the class is reading from standard input or from a",
                    "\t * stream, then the return value is null.",
                    "\t */",
                    "\tpublic static String getInputFileName() {",
                    "\t\treturn inputFileName;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * If TextIO is currently writing to a file, then the return value is the",
                    "\t * name of the file. If the class is writing to standard output or to a",
                    "\t * stream, then the return value is null.",
                    "\t */",
                    "\tpublic static String getOutputFileName() {",
                    "\t\treturn outputFileName;",
                    "\t}",
                    "",
                    "\t// *************************** Output Methods",
                    "\t// *********************************",
                    "",
                    "\t/**",
                    "\t * Write a single value to the current output destination, using the default",
                    "\t * format and no extra spaces. This method will handle any type of",
                    "\t * parameter, even one whose type is one of the primitive types.",
                    "\t */",
                    "\tpublic static void put(Object x) {",
                    "\t\tout.print(x);",
                    "\t\tout.flush();",
                    "\t\tif (out.checkError())",
                    "\t\t\toutputError(\"Error while writing output.\");",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Write a single value to the current output destination, using the default",
                    "\t * format and outputting at least minChars characters (with extra spaces",
                    "\t * added before the output value if necessary). This method will handle any",
                    "\t * type of parameter, even one whose type is one of the primitive types.",
                    "\t * ",
                    "\t * @param x",
                    "\t *            The value to be output, which can be of any type.",
                    "\t * @param minChars",
                    "\t *            The minimum number of characters to use for the output. If x",
                    "\t *            requires fewer then this number of characters, then extra",
                    "\t *            spaces are added to the front of x to bring the total up to",
                    "\t *            minChars. If minChars is less than or equal to zero, then x",
                    "\t *            will be printed in the minumum number of spaces possible.",
                    "\t */",
                    "\tpublic static void put(Object x, int minChars) {",
                    "\t\tif (minChars <= 0)",
                    "\t\t\tout.print(x);",
                    "\t\telse",
                    "\t\t\tout.printf(\"%\" + minChars + \"s\", x);",
                    "\t\tout.flush();",
                    "\t\tif (out.checkError())",
                    "\t\t\toutputError(\"Error while writing output.\");",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * This is equivalent to put(x), followed by an end-of-line.",
                    "\t */",
                    "\tpublic static void putln(Object x) {",
                    "\t\tout.println(x);",
                    "\t\tout.flush();",
                    "\t\tif (out.checkError())",
                    "\t\t\toutputError(\"Error while writing output.\");",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * This is equivalent to put(x,minChars), followed by an end-of-line.",
                    "\t */",
                    "\tpublic static void putln(Object x, int minChars) {",
                    "\t\tput(x, minChars);",
                    "\t\tout.println();",
                    "\t\tout.flush();",
                    "\t\tif (out.checkError())",
                    "\t\t\toutputError(\"Error while writing output.\");",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Write an end-of-line character to the current output destination.",
                    "\t */",
                    "\tpublic static void putln() {",
                    "\t\tout.println();",
                    "\t\tout.flush();",
                    "\t\tif (out.checkError())",
                    "\t\t\toutputError(\"Error while writing output.\");",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Writes formatted output values to the current output destination. This",
                    "\t * method has the same function as System.out.printf(); the details of",
                    "\t * formatted output are not discussed here. The first parameter is a string",
                    "\t * that describes the format of the output. There can be any number of",
                    "\t * additional parameters; these specify the values to be output and can be",
                    "\t * of any type. This method will throw an IllegalArgumentException if the",
                    "\t * format string is null or if the format string is illegal for the values",
                    "\t * that are being output.",
                    "\t */",
                    "\tpublic static void putf(String format, Object... items) {",
                    "\t\tif (format == null)",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\"Null format string in TextIO.putf() method.\");",
                    "\t\ttry {",
                    "\t\t\tout.printf(format, items);",
                    "\t\t} catch (IllegalFormatException e) {",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\"Illegal format string in TextIO.putf() method.\");",
                    "\t\t}",
                    "\t\tout.flush();",
                    "\t\tif (out.checkError())",
                    "\t\t\toutputError(\"Error while writing output.\");",
                    "\t}",
                    "",
                    "\t// *************************** Input Methods",
                    "\t// *********************************",
                    "",
                    "\t/**",
                    "\t * Test whether the next character in the current input source is an",
                    "\t * end-of-line. Note that this method does NOT skip whitespace before",
                    "\t * testing for end-of-line -- if you want to do that, call skipBlanks()",
                    "\t * first.",
                    "\t */",
                    "\tpublic static boolean eoln() {",
                    "\t\treturn peek() == '\\n';",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Test whether the next character in the current input source is an",
                    "\t * end-of-file. Note that this method does NOT skip whitespace before",
                    "\t * testing for end-of-line -- if you want to do that, call skipBlanks() or",
                    "\t * skipWhitespace() first.",
                    "\t */",
                    "\tpublic static boolean eof() {",
                    "\t\treturn peek() == EOF;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Reads the next character from the current input source. The character can",
                    "\t * be a whitespace character; compare this to the getChar() method, which",
                    "\t * skips over whitespace and returns the next non-whitespace character. An",
                    "\t * end-of-line is always returned as the character '\\n', even when the",
                    "\t * actual end-of-line in the input source is something else, such as '\\r' or",
                    "\t * \"\\r\\n\". This method will throw an IllegalArgumentException if the input",
                    "\t * is at end-of-file (which will not ordinarily happen if reading from",
                    "\t * standard input).",
                    "\t */",
                    "\tpublic static char getAnyChar() {",
                    "\t\treturn readChar();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Returns the next character in the current input source, without actually",
                    "\t * removing that character from the input. The character can be a whitespace",
                    "\t * character and can be the end-of-file character (specfied by the constant",
                    "\t * TextIO.EOF).An end-of-line is always returned as the character '\\n', even",
                    "\t * when the actual end-of-line in the input source is something else, such",
                    "\t * as '\\r' or \"\\r\\n\". This method never causes an error.",
                    "\t */",
                    "\tpublic static char peek() {",
                    "\t\treturn lookChar();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips over any whitespace characters, except for end-of-lines. After this",
                    "\t * method is called, the next input character is either an end-of-line, an",
                    "\t * end-of-file, or a non-whitespace character. This method never causes an",
                    "\t * error. (Ordinarly, end-of-file is not possible when reading from standard",
                    "\t * input.)",
                    "\t */",
                    "\tpublic static void skipBlanks() {",
                    "\t\tchar ch = lookChar();",
                    "\t\twhile (ch != EOF && ch != '\\n' && Character.isWhitespace(ch)) {",
                    "\t\t\treadChar();",
                    "\t\t\tch = lookChar();",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips over any whitespace characters, including for end-of-lines. After",
                    "\t * this method is called, the next input character is either an end-of-file",
                    "\t * or a non-whitespace character. This method never causes an error.",
                    "\t * (Ordinarly, end-of-file is not possible when reading from standard",
                    "\t * input.)",
                    "\t */",
                    "\tprivate static void skipWhitespace() {",
                    "\t\tchar ch = lookChar();",
                    "\t\twhile (ch != EOF && Character.isWhitespace(ch)) {",
                    "\t\t\treadChar();",
                    "\t\t\tif (ch == '\\n' && readingStandardInput && writingStandardOutput) {",
                    "\t\t\t\t// Removed for SP08 UIUC CS125 out.print(\"? \");",
                    "\t\t\t\tout.flush();",
                    "\t\t\t}",
                    "\t\t\tch = lookChar();",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type byte from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). When using standard IO, this will",
                    "\t * not produce an error; the user will be prompted repeatedly for input",
                    "\t * until a legal value is input. In other cases, an IllegalArgumentException",
                    "\t * will be thrown if a legal value is not found.",
                    "\t */",
                    "\tpublic static byte getlnByte() {",
                    "\t\tbyte x = getByte();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type short from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). When using standard IO, this will",
                    "\t * not produce an error; the user will be prompted repeatedly for input",
                    "\t * until a legal value is input. In other cases, an IllegalArgumentException",
                    "\t * will be thrown if a legal value is not found.",
                    "\t */",
                    "\tpublic static short getlnShort() {",
                    "\t\tshort x = getShort();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type int from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). When using standard IO, this will",
                    "\t * not produce an error; the user will be prompted repeatedly for input",
                    "\t * until a legal value is input. In other cases, an IllegalArgumentException",
                    "\t * will be thrown if a legal value is not found.",
                    "\t */",
                    "\tpublic static int getlnInt() {",
                    "\t\tint x = getInt();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type long from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). When using standard IO, this will",
                    "\t * not produce an error; the user will be prompted repeatedly for input",
                    "\t * until a legal value is input. In other cases, an IllegalArgumentException",
                    "\t * will be thrown if a legal value is not found.",
                    "\t */",
                    "\tpublic static long getlnLong() {",
                    "\t\tlong x = getLong();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type float from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). When using standard IO, this will",
                    "\t * not produce an error; the user will be prompted repeatedly for input",
                    "\t * until a legal value is input. In other cases, an IllegalArgumentException",
                    "\t * will be thrown if a legal value is not found.",
                    "\t */",
                    "\tpublic static float getlnFloat() {",
                    "\t\tfloat x = getFloat();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type double from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). When using standard IO, this will",
                    "\t * not produce an error; the user will be prompted repeatedly for input",
                    "\t * until a legal value is input. In other cases, an IllegalArgumentException",
                    "\t * will be thrown if a legal value is not found.",
                    "\t */",
                    "\tpublic static double getlnDouble() {",
                    "\t\tdouble x = getDouble();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type char from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). Note that the value that is returned",
                    "\t * will be a non-whitespace character; compare this with the getAnyChar()",
                    "\t * method. When using standard IO, this will not produce an error. In other",
                    "\t * cases, an error can occur if an end-of-file is encountered.",
                    "\t */",
                    "\tpublic static char getlnChar() {",
                    "\t\tchar x = getChar();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type boolean from",
                    "\t * input, discarding the rest of the current line of input (including the",
                    "\t * next end-of-line character, if any). When using standard IO, this will",
                    "\t * not produce an error; the user will be prompted repeatedly for input",
                    "\t * until a legal value is input. In other cases, an IllegalArgumentException",
                    "\t * will be thrown if a legal value is not found.",
                    "\t * <p>",
                    "\t * Legal inputs for a boolean input are: true, t, yes, y, 1, false, f, no,",
                    "\t * n, and 0; letters can be either upper case or lower case. One \"word\" of",
                    "\t * input is read, using the getWord() method, and it must be one of these;",
                    "\t * note that the \"word\" must be terminated by a whitespace character (or",
                    "\t * end-of-file).",
                    "\t */",
                    "\tpublic static boolean getlnBoolean() {",
                    "\t\tboolean x = getBoolean();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads one \"word\" from input,",
                    "\t * discarding the rest of the current line of input (including the next",
                    "\t * end-of-line character, if any). A word is defined as a sequence of",
                    "\t * non-whitespace characters (not just letters!). When using standard IO,",
                    "\t * this will not produce an error. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if an end-of-file is encountered.",
                    "\t */",
                    "\tpublic static String getlnWord() {",
                    "\t\tString x = getWord();",
                    "\t\temptyBuffer();",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * This is identical to getln().",
                    "\t */",
                    "\tpublic static String getlnString() {",
                    "\t\treturn getln();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Reads all the charcters from the current input source, up to the next",
                    "\t * end-of-line. The end-of-line is read but is not included in the return",
                    "\t * value. Any other whitespace characters on the line are retained, even if",
                    "\t * they occur at the start of input. The return value will be an empty",
                    "\t * string if there are no no characters before the end-of-line. When using",
                    "\t * standard IO, this will not produce an error. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if an end-of-file is encountered.",
                    "\t */",
                    "\tpublic static String getln() {",
                    "\t\tStringBuffer s = new StringBuffer(100);",
                    "\t\tchar ch = readChar();",
                    "\t\twhile (ch != '\\n') {",
                    "\t\t\ts.append(ch);",
                    "\t\t\tch = readChar();",
                    "\t\t}",
                    "\t\treturn s.toString();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type byte from",
                    "\t * input. Any additional characters on the current line of input are",
                    "\t * retained, and will be read by the next input operation. When using",
                    "\t * standard IO, this will not produce an error; the user will be prompted",
                    "\t * repeatedly for input until a legal value is input. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if a legal value is not found.",
                    "\t */",
                    "\tprivate static byte getByte() {",
                    "\t\treturn (byte) readInteger(-128L, 127L);",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type short from",
                    "\t * input. Any additional characters on the current line of input are",
                    "\t * retained, and will be read by the next input operation. When using",
                    "\t * standard IO, this will not produce an error; the user will be prompted",
                    "\t * repeatedly for input until a legal value is input. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if a legal value is not found.",
                    "\t */",
                    "\tprivate static short getShort() {",
                    "\t\treturn (short) readInteger(-32768L, 32767L);",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type int from",
                    "\t * input. Any additional characters on the current line of input are",
                    "\t * retained, and will be read by the next input operation. When using",
                    "\t * standard IO, this will not produce an error; the user will be prompted",
                    "\t * repeatedly for input until a legal value is input. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if a legal value is not found.",
                    "\t */",
                    "\tprivate static int getInt() {",
                    "\t\treturn (int) readInteger(Integer.MIN_VALUE,",
                    "\t\t\t\tInteger.MAX_VALUE);",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type long from",
                    "\t * input. Any additional characters on the current line of input are",
                    "\t * retained, and will be read by the next input operation. When using",
                    "\t * standard IO, this will not produce an error; the user will be prompted",
                    "\t * repeatedly for input until a legal value is input. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if a legal value is not found.",
                    "\t */",
                    "\tprivate static long getLong() {",
                    "\t\treturn readInteger(Long.MIN_VALUE, Long.MAX_VALUE);",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a single non-whitespace",
                    "\t * character from input. Any additional characters on the current line of",
                    "\t * input are retained, and will be read by the next input operation. When",
                    "\t * using standard IO, this will not produce an error. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if an end-of-file is encountered.",
                    "\t */",
                    "\tprivate static char getChar() {",
                    "\t\tskipWhitespace();",
                    "\t\treturn readChar();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type float from",
                    "\t * input. Any additional characters on the current line of input are",
                    "\t * retained, and will be read by the next input operation. When using",
                    "\t * standard IO, this will not produce an error; the user will be prompted",
                    "\t * repeatedly for input until a legal value is input. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if a legal value is not found.",
                    "\t */",
                    "\tprivate static float getFloat() {",
                    "\t\tfloat x = 0.0F;",
                    "\t\twhile (true) {",
                    "\t\t\tString str = readRealString();",
                    "\t\t\tif (str == null) {",
                    "\t\t\t\terrorMessage(\"Floating point number not found.\",",
                    "\t\t\t\t\t\t\"Real number in the range \" + (-Float.MAX_VALUE)",
                    "\t\t\t\t\t\t\t\t+ \" to \" + Float.MAX_VALUE);",
                    "\t\t\t} else {",
                    "\t\t\t\ttry {",
                    "\t\t\t\t\tx = Float.parseFloat(str);",
                    "\t\t\t\t} catch (NumberFormatException e) {",
                    "\t\t\t\t\terrorMessage(\"Illegal floating point input, \" + str + \".\",",
                    "\t\t\t\t\t\t\t\"Real number in the range \" + (-Float.MAX_VALUE)",
                    "\t\t\t\t\t\t\t\t\t+ \" to \" + Float.MAX_VALUE);",
                    "\t\t\t\t\tcontinue;",
                    "\t\t\t\t}",
                    "\t\t\t\tif (Float.isInfinite(x)) {",
                    "\t\t\t\t\terrorMessage(",
                    "\t\t\t\t\t\t\t\"Floating point input outside of legal range, \"",
                    "\t\t\t\t\t\t\t\t\t+ str + \".\", \"Real number in the range \"",
                    "\t\t\t\t\t\t\t\t\t+ (-Float.MAX_VALUE) + \" to \"",
                    "\t\t\t\t\t\t\t\t\t+ Float.MAX_VALUE);",
                    "\t\t\t\t\tcontinue;",
                    "\t\t\t\t}",
                    "\t\t\t\tbreak;",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tinputErrorCount = 0;",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type double from",
                    "\t * input. Any additional characters on the current line of input are",
                    "\t * retained, and will be read by the next input operation. When using",
                    "\t * standard IO, this will not produce an error; the user will be prompted",
                    "\t * repeatedly for input until a legal value is input. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if a legal value is not found.",
                    "\t */",
                    "\tprivate static double getDouble() {",
                    "\t\tdouble x = 0.0;",
                    "\t\twhile (true) {",
                    "\t\t\tString str = readRealString();",
                    "\t\t\tif (str == null) {",
                    "\t\t\t\terrorMessage(\"Floating point number not found.\",",
                    "\t\t\t\t\t\t\"Real number in the range \" + (-Double.MAX_VALUE)",
                    "\t\t\t\t\t\t\t\t+ \" to \" + Double.MAX_VALUE);",
                    "\t\t\t} else {",
                    "\t\t\t\ttry {",
                    "\t\t\t\t\tx = Double.parseDouble(str);",
                    "\t\t\t\t} catch (NumberFormatException e) {",
                    "\t\t\t\t\terrorMessage(\"Illegal floating point input, \" + str + \".\",",
                    "\t\t\t\t\t\t\t\"Real number in the range \" + (-Double.MAX_VALUE)",
                    "\t\t\t\t\t\t\t\t\t+ \" to \" + Double.MAX_VALUE);",
                    "\t\t\t\t\tcontinue;",
                    "\t\t\t\t}",
                    "\t\t\t\tif (Double.isInfinite(x)) {",
                    "\t\t\t\t\terrorMessage(",
                    "\t\t\t\t\t\t\t\"Floating point input outside of legal range, \"",
                    "\t\t\t\t\t\t\t\t\t+ str + \".\", \"Real number in the range \"",
                    "\t\t\t\t\t\t\t\t\t+ (-Double.MAX_VALUE) + \" to \"",
                    "\t\t\t\t\t\t\t\t\t+ Double.MAX_VALUE);",
                    "\t\t\t\t\tcontinue;",
                    "\t\t\t\t}",
                    "\t\t\t\tbreak;",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tinputErrorCount = 0;",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads one \"word\" from input. Any",
                    "\t * additional characters on the current line of input are retained, and will",
                    "\t * be read by the next input operation. A word is defined as a sequence of",
                    "\t * non-whitespace characters (not just letters!). When using standard IO,",
                    "\t * this will not produce an error. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if an end-of-file is encountered.",
                    "\t */",
                    "\tpublic static String getWord() {",
                    "\t\tskipWhitespace();",
                    "\t\tStringBuffer str = new StringBuffer(50);",
                    "\t\tchar ch = lookChar();",
                    "\t\twhile (ch == EOF || !Character.isWhitespace(ch)) {",
                    "\t\t\tstr.append(readChar());",
                    "\t\t\tch = lookChar();",
                    "\t\t}",
                    "\t\treturn str.toString();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Skips whitespace characters and then reads a value of type boolean from",
                    "\t * input. Any additional characters on the current line of input are",
                    "\t * retained, and will be read by the next input operation. When using",
                    "\t * standard IO, this will not produce an error; the user will be prompted",
                    "\t * repeatedly for input until a legal value is input. In other cases, an",
                    "\t * IllegalArgumentException will be thrown if a legal value is not found.",
                    "\t * <p>",
                    "\t * Legal inputs for a boolean input are: true, t, yes, y, 1, false, f, no,",
                    "\t * n, and 0; letters can be either upper case or lower case. One \"word\" of",
                    "\t * input is read, using the getWord() method, and it must be one of these;",
                    "\t * note that the \"word\" must be terminated by a whitespace character (or",
                    "\t * end-of-file).",
                    "\t */",
                    "\tprivate static boolean getBoolean() {",
                    "\t\tboolean ans = false;",
                    "\t\twhile (true) {",
                    "\t\t\tString s = getWord();",
                    "\t\t\tif (s.equalsIgnoreCase(\"true\") || s.equalsIgnoreCase(\"t\")",
                    "\t\t\t\t\t|| s.equalsIgnoreCase(\"yes\") || s.equalsIgnoreCase(\"y\")",
                    "\t\t\t\t\t|| s.equals(\"1\")) {",
                    "\t\t\t\tans = true;",
                    "\t\t\t\tbreak;",
                    "\t\t\t} else if (s.equalsIgnoreCase(\"false\") || s.equalsIgnoreCase(\"f\")",
                    "\t\t\t\t\t|| s.equalsIgnoreCase(\"no\") || s.equalsIgnoreCase(\"n\")",
                    "\t\t\t\t\t|| s.equals(\"0\")) {",
                    "\t\t\t\tans = false;",
                    "\t\t\t\tbreak;",
                    "\t\t\t} else",
                    "\t\t\t\terrorMessage(\"Illegal boolean input value.\",",
                    "\t\t\t\t\t\t\"one of:  true, false, t, f, yes, no, y, n, 0, or 1\");",
                    "\t\t}",
                    "\t\tinputErrorCount = 0;",
                    "\t\treturn ans;",
                    "\t}",
                    "",
                    "\t// ***************** Everything beyond this point is private implementation",
                    "\t// detail *******************",
                    "",
                    "\tprivate static String inputFileName; // Name of file that is the current",
                    "",
                    "\t// input source, or null if the",
                    "\t// source is not a file.",
                    "\tprivate static String outputFileName; // Name of file that is the current",
                    "",
                    "\t// output destination, or null if",
                    "\t// the destination is not a file.",
                    "",
                    "\tprivate static JFileChooser fileDialog; // Dialog used by",
                    "",
                    "\t// readUserSelectedFile() and",
                    "\t// writeUserSelectedFile()",
                    "",
                    "\tprivate static BufferedReader standardInput = new BufferedReader(",
                    "\t\t\tnew InputStreamReader(System.in)); // wraps",
                    "",
                    "\t// standard",
                    "\t// input",
                    "\t// stream",
                    "\tprivate static PrintWriter standardOutput = new PrintWriter(",
                    "\t\t\tSystem.out); // wraps",
                    "",
                    "\t// standard",
                    "\t// output",
                    "\t// stream",
                    "",
                    "\tprivate static BufferedReader in = standardInput; // Stream that data is",
                    "",
                    "\t// read from; the",
                    "\t// current input source.",
                    "\tprivate static PrintWriter out = standardOutput; // Stream that data is",
                    "",
                    "\t// written to; the",
                    "\t// current output",
                    "\t// destination.",
                    "",
                    "\tprivate static boolean readingStandardInput = true;",
                    "",
                    "\tprivate static boolean writingStandardOutput = true;",
                    "",
                    "\tprivate static int inputErrorCount; // Number of consecutive errors on",
                    "",
                    "\t// standard input; reset to 0 when a",
                    "\t// successful read occurs.",
                    "\tprivate static int outputErrorCount; // Number of errors on standard",
                    "",
                    "\t// output since it was selected as",
                    "\t// the output destination.",
                    "",
                    "\tprivate static Matcher integerMatcher; // Used for reading integer numbers;",
                    "",
                    "\t// created from the integer Regex",
                    "\t// Pattern.",
                    "\tprivate static Matcher floatMatcher; // Used for reading floating point",
                    "",
                    "\t// numbers; created from the",
                    "\t// floatRegex Pattern.",
                    "\tprivate final static Pattern integerRegex = Pattern",
                    "\t\t\t.compile(\"(\\\\+|-)?[0-9]+\");",
                    "",
                    "\tprivate final static Pattern floatRegex = Pattern",
                    "\t\t\t.compile(\"(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))((e|E)(\\\\+|-)?[0-9]+)?\");",
                    "",
                    "\tprivate static String buffer = null; // One line read from input.",
                    "",
                    "\tprivate static int pos = 0; // Position of next char in input",
                    "",
                    "\tprivate static String readRealString() { // read chars from input",
                    "\t\t// following syntax of real",
                    "\t\t// numbers",
                    "\t\tskipWhitespace();",
                    "\t\tif (lookChar() == EOF)",
                    "\t\t\treturn null;",
                    "\t\tif (floatMatcher == null)",
                    "\t\t\tfloatMatcher = floatRegex.matcher(buffer);",
                    "\t\tfloatMatcher.region(pos, buffer.length());",
                    "\t\tif (floatMatcher.lookingAt()) {",
                    "\t\t\tString str = floatMatcher.group();",
                    "\t\t\tpos = floatMatcher.end();",
                    "\t\t\treturn str;",
                    "\t\t}",
                    "\t\t// else implied",
                    "\t\treturn null;",
                    "\t}",
                    "",
                    "\tprivate static String readIntegerString() { // read chars from input",
                    "\t\t// following syntax of integers",
                    "\t\tskipWhitespace();",
                    "\t\tif (lookChar() == EOF)",
                    "\t\t\treturn null;",
                    "\t\tif (integerMatcher == null)",
                    "\t\t\tintegerMatcher = integerRegex.matcher(buffer);",
                    "\t\tintegerMatcher.region(pos, buffer.length());",
                    "\t\tif (integerMatcher.lookingAt()) {",
                    "\t\t\tString str = integerMatcher.group();",
                    "\t\t\tpos = integerMatcher.end();",
                    "\t\t\treturn str;",
                    "\t\t} ",
                    "\t\t// else implied",
                    "\t\treturn null;",
                    "\t}",
                    "",
                    "\tprivate static long readInteger(long min, long max) { // read long",
                    "\t\t// integer, limited",
                    "\t\t// to specified",
                    "\t\t// range",
                    "\t\tlong x = 0;",
                    "\t\twhile (true) {",
                    "\t\t\tString s = readIntegerString();",
                    "\t\t\tif (s == null) {",
                    "\t\t\t\terrorMessage(\"Integer value not found in input.\",",
                    "\t\t\t\t\t\t\"Integer in the range \" + min + \" to \" + max);",
                    "\t\t\t} else {",
                    "\t\t\t\tString str = s.toString();",
                    "\t\t\t\ttry {",
                    "\t\t\t\t\tx = Long.parseLong(str);",
                    "\t\t\t\t} catch (NumberFormatException e) {",
                    "\t\t\t\t\terrorMessage(\"Illegal integer input, \" + str + \".\",",
                    "\t\t\t\t\t\t\t\"Integer in the range \" + min + \" to \" + max);",
                    "\t\t\t\t\tcontinue;",
                    "\t\t\t\t}",
                    "\t\t\t\tif (x < min || x > max) {",
                    "\t\t\t\t\terrorMessage(\"Integer input outside of legal range, \" + str",
                    "\t\t\t\t\t\t\t+ \".\", \"Integer in the range \" + min + \" to \" + max);",
                    "\t\t\t\t\tcontinue;",
                    "\t\t\t\t}",
                    "\t\t\t\tbreak;",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tinputErrorCount = 0;",
                    "\t\treturn x;",
                    "\t}",
                    "",
                    "\tprivate static void errorMessage(String message, String expecting) { // Report",
                    "\t\t// error",
                    "\t\t// on",
                    "\t\t// input.",
                    "\t\tif (readingStandardInput && writingStandardOutput) {",
                    "\t\t\t// inform user of error and force user to re-enter.",
                    "\t\t\tout.println();",
                    "\t\t\tout.print(\"  *** Error in input: \" + message + \"\\n\");",
                    "\t\t\tout.print(\"  *** Expecting: \" + expecting + \"\\n\");",
                    "\t\t\tout.print(\"  *** Discarding Input: \");",
                    "\t\t\tif (lookChar() == '\\n')",
                    "\t\t\t\tout.print(\"(end-of-line)\\n\\n\");",
                    "\t\t\telse {",
                    "\t\t\t\twhile (lookChar() != '\\n')",
                    "\t\t\t\t\t// Discard and echo remaining chars",
                    "\t\t\t\t\t// on the current line of input.",
                    "\t\t\t\t\tout.print(readChar());",
                    "\t\t\t\tout.print(\"\\n\\n\");",
                    "\t\t\t}",
                    "\t\t\tout.print(\"Please re-enter: \");",
                    "\t\t\tout.flush();",
                    "\t\t\treadChar(); // discard the end-of-line character",
                    "\t\t\tinputErrorCount++;",
                    "\t\t\tif (inputErrorCount >= 10)",
                    "\t\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\t\"Too many input consecutive input errors on standard input.\");",
                    "\t\t} else if (inputFileName != null)",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\"Error while reading from file \\\"\" + inputFileName",
                    "\t\t\t\t\t\t\t+ \"\\\":\\n\" + message + \"\\nExpecting \" + expecting);",
                    "\t\telse",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\"Error while reading from inptu stream:\\n\" + message",
                    "\t\t\t\t\t\t\t+ \"\\nExpecting \" + expecting);",
                    "\t}",
                    "",
                    "\tprivate static char lookChar() { // return next character from input",
                    "\t\tif (buffer == null || pos > buffer.length())",
                    "\t\t\tfillBuffer();",
                    "\t\tif (buffer == null)",
                    "\t\t\treturn EOF;",
                    "\t\telse if (pos == buffer.length())",
                    "\t\t\treturn '\\n';",
                    "\t\telse",
                    "\t\t\treturn buffer.charAt(pos);",
                    "\t}",
                    "",
                    "\tprivate static char readChar() { // return and discard next character",
                    "\t\t// from input",
                    "\t\tchar ch = lookChar();",
                    "\t\tif (buffer == null) {",
                    "\t\t\tif (readingStandardInput)",
                    "\t\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\t\"Attempt to read past end-of-file in standard input???\");",
                    "\t\t\t//else is implied",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\t\"Attempt to read past end-of-file in file \\\"\"",
                    "\t\t\t\t\t\t\t\t+ inputFileName + \"\\\".\");",
                    "\t\t}",
                    "\t\tpos++;",
                    "\t\treturn ch;",
                    "\t}",
                    "",
                    "\tprivate static void fillBuffer() { // Wait for user to type a line and",
                    "\t\t// press return,",
                    "\t\ttry {",
                    "\t\t\tbuffer = in.readLine();",
                    "\t\t} catch (Exception e) {",
                    "\t\t\tif (readingStandardInput)",
                    "\t\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\t\"Error while reading standard input???\");",
                    "\t\t\telse if (inputFileName != null)",
                    "\t\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\t\"Error while attempting to read from file \\\"\"",
                    "\t\t\t\t\t\t\t\t+ inputFileName + \"\\\".\");",
                    "\t\t\telse",
                    "\t\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\t\"Errow while attempting to read form an input stream.\");",
                    "\t\t}",
                    "\t\tpos = 0;",
                    "\t\tfloatMatcher = null;",
                    "\t\tintegerMatcher = null;",
                    "",
                    "\t\t// integerMatcher = null; //current last line of fillBuffer()",
                    "\t\t// xxxif ( ! readingStandardInput ) putln(buffer); // ECHO",
                    "\t}",
                    "",
                    "\tprivate static void emptyBuffer() { // discard the rest of the current",
                    "\t\t// line of input",
                    "\t\tbuffer = null;",
                    "\t}",
                    "",
                    "\tprivate static void outputError(String message) { // Report an error on",
                    "\t\t// output.",
                    "\t\tif (writingStandardOutput) {",
                    "\t\t\tSystem.err",
                    "\t\t\t\t\t.println(\"Error occurred in TextIO while writing to standard output!!\");",
                    "\t\t\toutputErrorCount++;",
                    "\t\t\tif (outputErrorCount >= 10) {",
                    "\t\t\t\toutputErrorCount = 0;",
                    "\t\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\t\"Too many errors while writing to standard output.\");",
                    "\t\t\t}",
                    "\t\t} else if (outputFileName != null) {",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\"Error occurred while writing to file \\\"\" + outputFileName",
                    "\t\t\t\t\t\t\t+ \"\\\":\\n   \" + message);",
                    "\t\t} else {",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t\t\"Error occurred while writing to output stream:\\n   \"",
                    "\t\t\t\t\t\t\t+ message);",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/** Methods added for UIUC CS125 */",
                    "",
                    "\tpublic static void rewrapStandardInputOutput() {",
                    "\t\tstandardInput = new BufferedReader(new InputStreamReader(System.in)); // wraps",
                    "\t\tstandardOutput = new PrintWriter(System.out);",
                    "\t\tif(writingStandardOutput)",
                    "\t\t\tout = standardOutput;",
                    "\t\tif(readingStandardInput)",
                    "\t\t\tin = standardInput;",
                    "\t\temptyBuffer();\t\t",
                    "\t}",
                    "} // end of class TextIO"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 1164
        },
        {
            "id": "codeNJMDfp",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.ArrayList;",
                    "import java.util.Collections;",
                    "import java.util.Iterator;",
                    "import java.util.RandomAccess;",
                    "import java.util.Scanner;",
                    "",
                    "/**",
                    " * Student class. Stores information regarding a particular Student in class, ",
                    " * including their lecture attendance and possibly grades. Each Student",
                    " * will contain all the proper PeerInteractions made by the student.",
                    " *",
                    " * @author CS125 Research",
                    " * @todo Implement more.",
                    " */",
                    "class Student implements Iterable<PeerInteraction>{",
                    "\tpublic static final float WEIGHT_PROPORTIONALITY_CONSTANT = 1;",
                    "\tpublic static final float WEIGHT_THRESHOLD = 10;",
                    "\t",
                    "\t/* ID of this Student. This value is immutable. */",
                    "\tprivate final int ID;",
                    "\t",
                    "\t//private boolean female; //One possibility for what we could store here",
                    "\t",
                    "\t/* The collection of all PeerInteractions made by the Student, sorted",
                    "\t * in chronological order. */",
                    "\tprivate ArrayList<PeerInteraction> records;",
                    "",
                    "\t/* Caching variables for several computationally nontrivial methods.",
                    "\t * Stores results of these method calls and is recomputed whenever",
                    "\t * the Student is mutated. */",
                    "\tprivate float weight = Float.NaN;",
                    "\tprivate float ratingMean = Float.NaN;",
                    "\tprivate float ratingStdDev = Float.NaN;",
                    "\t/* When the cache is to be refreshed, this boolean is set true. Any",
                    "\t * methods that use the above variables will recompute values when",
                    "\t * this boolean is set. See refreshCache()*/",
                    "\tprivate boolean mutated = false;",
                    "\t",
                    " \t/**",
                    " \t * ID Ctor. Needs work?",
                    " \t * ",
                    " \t * @param code The ID of the Student.",
                    " \t */",
                    "\tpublic Student(int code){",
                    "\t\tID = code;",
                    "\t\trecords = new ArrayList<PeerInteraction>();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * ID and one-entry Ctor. Is this useful?",
                    "\t * ",
                    "\t * @param entry The first PeerInteraction made by this student.",
                    "\t */",
                    "\tpublic Student(PeerInteraction entry){",
                    "\t\tthis(entry.getPersonID());",
                    "\t\trecords.add(entry);",
                    "\t\trefreshCache();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Computes and returns the weight of this Student, used when calculating",
                    "\t * weighted grade distributions for a Lecture. ",
                    "\t *",
                    "\t * Formula: (2 * Number of records by student) / (Number of times the record had a feedback rating of 5 OR 10)",
                    "\t * \tWeight can be a max of WEIGHT_THRESHOLD",
                    "\t *",
                    "\t * @return The weight given to this Student's feedback.",
                    "\t */",
                    "\tpublic double feedbackWeight(){",
                    "\t\tif (!mutated)",
                    "\t\t\treturn WEIGHT_PROPORTIONALITY_CONSTANT*weight;",
                    "\t\tif (records.size() == 0)",
                    "\t\t\treturn Double.NaN;",
                    "\t\tint numberOfCommonResponses = 0; // For now, if the feedback was 5 or 10, it's not important",
                    "\t\tfor(int i = 0; i < records.size(); i++){",
                    "\t\t\tif(records.get(i).getGrade() == 5 || records.get(i).getGrade() == 10){",
                    "\t\t\t\tnumberOfCommonResponses++;",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tif(numberOfCommonResponses > 0)",
                    "\t\t\tweight = (2*records.size())/numberOfCommonResponses;",
                    "\t\telse",
                    "\t\t\tweight = WEIGHT_THRESHOLD;",
                    "\t\t",
                    "\t\tif(weight > WEIGHT_THRESHOLD)",
                    "\t\t\tweight = WEIGHT_THRESHOLD;",
                    "\t\t",
                    "\t\treturn WEIGHT_PROPORTIONALITY_CONSTANT*weight;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Add a PeerInteraction to this Student's record thereof. This method ",
                    "\t * will sort the record by date after insertion. Throws an exception ",
                    "\t * if an entry passed in has a personID which differs from this.ID .",
                    "\t *",
                    "\t * @param entry PeerInteraction made by this Student",
                    "\t */",
                    "\tpublic void addEntry(PeerInteraction entry){",
                    "\t\tif (entry.getPersonID() != ID)",
                    "\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t    String.format(\"Student %d given entry by %d\",",
                    "\t\t\t\t          ID, entry.getPersonID()) );",
                    "\t\trecords.add(entry);",
                    "\t\tpushBack();",
                    "\t\trefreshCache();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * @return The ID code of this student.",
                    "\t */",
                    "\tpublic int getID(){",
                    "\t\treturn ID;",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * @return Number of valid peer interaction data points given by this Student.",
                    "\t */",
                    "\tpublic int feedbackGiven(){",
                    "\t\treturn records.size();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * @return The average rating given by this Student for all lectures ",
                    "\t *         so far in the semester.",
                    "\t */",
                    "\tpublic float ratingMean(){",
                    "\t\tif (!mutated)",
                    "\t\t\treturn ratingMean;",
                    "\t\tif (records.size() == 0)",
                    "\t\t\treturn Float.NaN;",
                    "\t\tlong sum = 0;",
                    "\t\tfor (PeerInteraction elem : records)",
                    "\t\t\tsum += elem.getGrade();",
                    "\t\treturn ratingMean = ((float) sum)/records.size();",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * @return The standard deviation of all ratings given by this",
                    "\t *         Student throughout the semester",
                    "\t */",
                    "\tpublic float ratingStdDev(){",
                    "\t\tif (!mutated)",
                    "\t\t\treturn ratingStdDev;",
                    "\t\tif (records.size() == 0)",
                    "\t\t\treturn Float.NaN;",
                    "\t\tlong sumSquared = 0;",
                    "\t\tdouble mean = ratingMean();",
                    "\t\tfor (PeerInteraction elem : records)",
                    "\t\t\tsumSquared += (elem.getGrade()*elem.getGrade());",
                    "\t\tdouble meanSquared = ((float) sumSquared)/records.size();",
                    "\t\treturn ratingStdDev = (float) Math.sqrt(meanSquared-mean*mean);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Ensures that the last few entries added are from distinct lectures.",
                    "\t * If duplicates are found, all will be merged into a single entry.",
                    "\t * This is public for now because it's unclear where it should be",
                    "\t * called.",
                    "\t */",
                    "\tpublic void mergeRecentDuplicates(){",
                    "\t\tint last = records.size()-1;",
                    "\t\twhile (last > 0){;",
                    "\t\t\tLecture curr = Lecture.get(records.get(last));",
                    "\t\t\tLecture prev = Lecture.get(records.get(last));",
                    "\t\t\tif (curr != prev)",
                    "\t\t\t\tbreak;",
                    "\t\t\telse",
                    "\t\t\t\t--last;",
                    "\t\t}",
                    "\t\tif (last != records.size()-1){",
                    "\t\t\tPeerInteraction[] repeats ",
                    "\t\t\t    = new PeerInteraction[records.size()-last];",
                    "\t\t\tfor (int idx = 0; idx < records.size()-last; ++idx)",
                    "\t\t\t\trepeats[idx] = records.get(idx+last);",
                    "\t\t\tfor (int idx = records.size()-1; idx >= last; ++idx)",
                    "\t\t\t\trecords.remove(idx); //Shame Java has no removeLast",
                    "\t\t\trecords.add(new PeerInteraction(repeats));",
                    "\t\t\trefreshCache(); //Recomputation needed due to changes",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Performs the same function as mergeRecentDuplicates(), but does",
                    "\t * so for all entries added. This might be slower but also might",
                    "\t * preferable due to lack of preconditions.",
                    "\t */",
                    "\tpublic void mergeAllDuplicates(){",
                    "\t\tArrayList<PeerInteraction> newRecords = new ArrayList<>();",
                    "\t\tArrayList<PeerInteraction> bucket = new ArrayList<>();",
                    "\t\tLecture last = null;",
                    "\t\tPeerInteraction[] merged = new PeerInteraction[1];",
                    "\t\tfor (PeerInteraction entry : records){",
                    "\t\t\tLecture curr = Lecture.get(entry);",
                    "\t\t\tif (curr != last && bucket.size() > 0){",
                    "\t\t\t\tmerged = new PeerInteraction[bucket.size()];",
                    "\t\t\t\tbucket.toArray(merged);",
                    "\t\t\t\tnewRecords.add(new PeerInteraction(merged));",
                    "\t\t\t\tbucket = new ArrayList<>();",
                    "\t\t\t}",
                    "\t\t\tbucket.add(entry);",
                    "\t\t\tlast = curr;",
                    "\t\t}",
                    "\t\tif (bucket.size() > 0){",
                    "\t\t\tmerged = new PeerInteraction[bucket.size()];",
                    "\t\t\tbucket.toArray(merged);",
                    "\t\t\tnewRecords.add(new PeerInteraction(merged));",
                    "\t\t}",
                    "\t\trecords = newRecords;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Private function that refreshes all cached variables. Setting",
                    "\t * mutated to true causes all functions to recompute instead",
                    "\t * of returning their cached values.",
                    "\t */",
                    "\tprivate void refreshCache(){",
                    "\t\tmutated = true;",
                    "\t\tratingMean();",
                    "\t\tratingStdDev();",
                    "\t\tfeedbackWeight();",
                    "\t\tmutated = false;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Private helper function that pushes back an unsorted entry to",
                    "\t * its proper spot in Student.records. Called whenever an entry is",
                    "\t * added.",
                    "\t */",
                    "\tprivate void pushBack(){",
                    "\t\tint last = records.size()-1;",
                    "\t\twhile (last > 0 ",
                    "\t\t    && records.get(last-1).getDate().compareTo(",
                    "\t\t           records.get(last).getDate()) > 0){",
                    "\t\t//^ Java verbosity in a nutshell.",
                    "\t\t//  Translation: records[last-1].getDate() > records[last].getDate();",
                    "\t\t\tCollections.swap(records, last-1, last);",
                    "\t\t\t--last;",
                    "\t\t}",
                    "\t}",
                    "",
                    "",
                    "\t/**",
                    "\t * Chronological iterator that points to the first element of",
                    "\t * records.",
                    "\t */",
                    "\tpublic InteractionIterator iterator() { return new InteractionIterator(); }",
                    "",
                    "\tpublic class InteractionIterator implements Iterator<PeerInteraction>{",
                    "\t\tprivate int curr;",
                    "\t\tpublic InteractionIterator()     { curr = 0; }",
                    "\t\tpublic boolean hasNext()         { return curr < records.size();}",
                    "\t\tpublic PeerInteraction next()    { return records.get(curr++); }",
                    "\t\tpublic void remove() { throw new UnsupportedOperationException(); } ",
                    "\t}",
                    "",
                    "\t",
                    "\t/**",
                    "\t * For now, this test method only works for feedback files without",
                    "\t * NRLists (so all netIDs must be integers). It also writes nothing",
                    "\t * to any files. It mainly tests to see if mergeDuplicates works.",
                    "\t * The parameters DUPLICATE and INVALID_ID are ratios that indicate",
                    "\t * the probability of this test inserting duplicate entries and",
                    "\t * trying to add entries with a mismatched ID (for testing).",
                    "\t * ",
                    "\t * @args The source file for PeerInteractions or nothing",
                    "\t */",
                    "\tpublic static void main(String[] args){",
                    "\t\tLectureData.initialize();",
                    "\t\tString fileName = args.length == 1 ? args[0] : null;",
                    "\t\tdouble DUPLICATE = 0.02; //Chance of generating duplicate",
                    "\t\tdouble INVALID_ID = 0.15; //Chance of improper parter ID",
                    "\t\tScanner safeScan = new Scanner(System.in);",
                    "\t\tif (fileName == null){",
                    "\t\t\tSystem.out.print(\"Enter the name of a feedback source file: \");",
                    "\t\t\tfileName = safeScan.nextLine();",
                    "\t\t\tTextIO.readFile(fileName);",
                    "\t\t}",
                    "\t\tArrayList<PeerInteraction> results = new ArrayList<PeerInteraction>();",
                    "\t\twhile (!TextIO.eof()){",
                    "\t\t\ttry{",
                    "\t\t\t\tPeerInteraction temp = new PeerInteraction(TextIO.getln());",
                    "\t\t\t\tresults.add(temp);",
                    "\t\t\t}catch(Exception e) {/* Do nothing */}",
                    "\t\t}",
                    "\t\tPeerInteraction rand;",
                    "\t\tdo{",
                    "\t\t\trand = results.get((int) (results.size()*Math.random()));",
                    "\t\t}while(!rand.valid());",
                    "\t\tStudent trial = new Student(rand); //This will lead to duplication",
                    "\t\tCollections.shuffle(results);     //Tests functionality of pushBack()",
                    "\t\tfor (PeerInteraction elem : results){",
                    "\t\t\tif (elem.getPersonID() != trial.getID() &&",
                    "\t\t\t    Math.random() >= INVALID_ID)",
                    "\t\t\t\tcontinue;",
                    "\t\t\ttry{",
                    "\t\t\t\ttrial.addEntry(elem);",
                    "\t\t\t\twhile (Math.random() < DUPLICATE)",
                    "\t\t\t\t\ttrial.addEntry(elem);",
                    "\t\t\t}catch(IllegalArgumentException e){",
                    "\t\t\t\tSystem.out.printf(\"Caught bad add: %s\\n\", e.getMessage());",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tSystem.out.println(\"Data with possible duplicates:\");",
                    "\t\tfor(PeerInteraction elem : trial)",
                    "\t\t\tSystem.out.println(elem);",
                    "\t\ttrial.mergeAllDuplicates();",
                    "\t\tSystem.out.println(\"\\n\\nData with duplicates merged:\");",
                    "\t\tfor (PeerInteraction elem : trial)",
                    "\t\t\tSystem.out.println(elem);",
                    "\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 311
        },
        {
            "id": "codeTcSBkL",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "/**",
                    " * A container which stores all Students in the class for processing. Implements",
                    " * a constant-time getter method which maps student ID codes to their",
                    " * corresponding Student objects. ",
                    " *",
                    " * @author CS125 Research",
                    " * @todo Add useful features. Also implement Student class and add needed",
                    " *       functionality to NRList class.",
                    " */",
                    "import java.util.*;",
                    "public class Roster implements Iterable<Student>{",
                    "",
                    "\tprivate Student[] map;",
                    "\tprivate int numStudents;",
                    "\t",
                    "\t/**",
                    "\t * Constructor for the Roster class. Creates an array of specified capacity",
                    "\t * and keeps it empty. Students can be manually added later to the Roster",
                    "\t * via the addStudent(int) method.",
                    "\t */",
                    "\tpublic Roster(int capacity){",
                    "\t\tmap = new Student[capacity];",
                    "\t\tnumStudents = 0;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Constructor for the Roster class. Creates an array of specified capacity",
                    "\t * and fills it up with new Student objects. The Students are initialized",
                    "\t * based off the ID codes in the NRList argument.",
                    "\t * ",
                    "\t * @codes    An NRList containing all the encoded netIDs in the class roster.",
                    "\t * @capacity The maximum number of students that can be added (can be changed).",
                    "\t */",
                    "\tpublic Roster(NRList codes, int capacity){",
                    "\t\tthis(capacity);",
                    "\t\t/* Goes through all the ID codes in the NRList argument and creates a",
                    "\t\t * Student object for each one. The Students created are stored in an",
                    "\t\t * array at the index corresponding to their ID codes. So map[154] would",
                    "\t\t * correspond to the Student whose ID code is 154. That being said, we",
                    "\t\t * should ensure that the range of Student ID codes is relatively small",
                    "\t\t * or else the array will waste space.",
                    "\t\t */",
                    "\t\tfor (NetIDPair elem : codes){",
                    "\t\t\tmap[elem.getCode()] = new Student(elem.getCode());",
                    "\t\t\tnumStudents = codes.size();",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Given an ID, returns the Student with the matching ID in the Roster. ",
                    "\t * Returns null if the ID is not found. This method is guaranteed to",
                    "\t * run in constant time.",
                    "\t *",
                    "\t * @param ID The code associated with a particular student.",
                    "\t *",
                    "\t * @return The student associated with the given code or null.",
                    "\t */",
                    "\tpublic Student get(int ID){",
                    "\t\tif (ID >= map.length || ID < 0)",
                    "\t\t\treturn null;",
                    "\t\telse",
                    "\t\t\treturn map[ID];",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Given a PeerInteraction, returns the Student in the Roster whose ID",
                    "\t * matches the first netID of the argument or null if no such Student",
                    "\t * is found.",
                    "\t * ",
                    "\t * @param interaction The PeerInteraction whose author will be sought.",
                    "\t * @return the student who authored the interaction or null.",
                    "\t */",
                    "\tpublic Student get(PeerInteraction interaction){",
                    "\t\treturn get(interaction.getPersonID());",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * This method matches all elements from a batch of PeerInteractions",
                    "\t * to individual Students in this Roster and assigns those",
                    "\t * PeerInteractions to their corresponding students using",
                    "\t * Student.addEntry(PeerInteraction).",
                    "\t * ",
                    "\t * @param batch A collection of PeerInteractions to be added.",
                    "\t */",
                    "\tpublic void addInteractions(Iterable<PeerInteraction> batch){",
                    "\t\tfor (PeerInteraction entry : batch){",
                    "\t\t\tStudent person = get(entry);",
                    "\t\t\tif (person != null)",
                    "\t\t\t\tperson.addEntry(entry);",
                    "\t\t}",
                    "\t\tfor (Student person : this)",
                    "\t\t\tperson.mergeRecentDuplicates(); //All or Recent?",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The number of students in the Roster.",
                    "\t */",
                    "\tpublic int size()     { return numStudents; }",
                    "\t",
                    "\t/**",
                    "\t * @return The number of students this Roster can contain.",
                    "\t */",
                    "\tpublic int capacity() { return map.length; }",
                    "\t",
                    "\t/**",
                    "\t * In case new Students join the class, allows addition of new Student to",
                    "\t * Roster. Ensure extra space when constructing Roster or else this will",
                    "\t * not be possible.",
                    "\t */",
                    "\tpublic void addStudent(int ID){",
                    "\t\tif (ID < 0 || ID >= map.length)",
                    "\t\t\tthrow new ",
                    "\t\t\t    IndexOutOfBoundsException(ID + \" is out of Roster Range.\");",
                    "\t\tif (map[ID] != null)",
                    "\t\t\tthrow new IllegalArgumentException(ID + \" is already taken.\");",
                    "\t\tmap[ID] = new Student(ID);",
                    "\t\t++numStudents;",
                    "\t}",
                    "\t ",
                    "\t/**",
                    "\t * Resizes this Roster to allow addition of more Students. If shrinking",
                    "\t * the Roster would cut off existing students, throws an exception.",
                    "\t *",
                    "\t * @param newSize New size of Roster.",
                    "\t */",
                    "\tpublic void resize(int newSize){",
                    "\t\tint max = map.length;",
                    "\t\twhile (map[--max] == null);",
                    "\t\tif (newSize < max)",
                    "\t\t\tthrow new",
                    "\t\t\t    IndexOutOfBoundsException(\"Minimum capacity needed: \" + max);",
                    "\t\tStudent[] newMap = new Student[newSize];",
                    "\t\tfor (int i = 0; i < map.length; ++i)",
                    "\t\t\tnewMap[i] = map[i];",
                    "\t\tmap = newMap;",
                    "\t}",
                    "\t",
                    "\t",
                    "\t/**",
                    "\t * @return An iterator to the first Student in this Roster (in order of",
                    "\t *         increasing ID)",
                    "\t */",
                    "\tpublic StudentIterator iterator() { return new StudentIterator(); }",
                    "",
                    "\t/**",
                    "\t * Hashmap iterator. Jumps from one non-null element of map to the next.",
                    "\t */",
                    "\tpublic class StudentIterator implements Iterator<Student>{",
                    "\t\tprivate int curr;",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * Helper function that jumps to the next non-null element",
                    "\t\t * of map or until the end of map is reached.",
                    "\t\t */",
                    "\t\tprivate void jump(){ ",
                    "\t\t\twhile (hasNext() && map[curr] == null)",
                    "\t\t\t\t++curr;",
                    "\t\t}",
                    "\t\tpublic StudentIterator() { curr = 0; jump(); }",
                    "\t\tpublic boolean hasNext() { return curr < map.length ; }",
                    "\t\tpublic Student next(){",
                    "\t\t\tStudent out = map[curr++];",
                    "\t\t\tjump();",
                    "\t\t\treturn out;",
                    "\t\t}",
                    "",
                    "\t\t@Override",
                    "\t\tpublic void remove() {",
                    "\t\t\t// TODO Auto-generated method stub",
                    "\t\t\t",
                    "\t\t}",
                    "",
                    "\t\t",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Simple main function. Shows that the iterator for this class",
                    "\t * works properly.",
                    "\t * ",
                    "\t */",
                    "\tpublic static void main(String[] args){",
                    "\t\t",
                    "\t\t",
                    "\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 185
        },
        {
            "id": "codeY5LBG1",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.*;",
                    "",
                    "/**",
                    " * @author CS125Research",
                    " */",
                    "public class PeerInteractionsData {",
                    "",
                    "\t/**Raw (uncleaned) PeerInteraction objects constructed",
                    "\t *  from the \"peerInteractions.fa2015.final.csv\" file.",
                    "\t *\tNOTE: entries could be corrupt **/",
                    "\tpublic static ArrayList<PeerInteraction> rawData;",
                    "\t/** The valid PeerInteraction objects filtered from the \"rawData\" list. */",
                    "\tpublic static ArrayList<PeerInteraction> cleanData;",
                    "\t",
                    "\t/** The percent of valid PeerInteraction objects constructed",
                    "\t *  from the CSV file and held in the cleanData list. */",
                    "\tpublic static double percentValid = -1;",
                    "\t/** The number of valid PeerInteraction objects constructed",
                    "\t *  from the CSV file and held in the cleanData list. */",
                    "\tpublic static int numberOfValidEntries = -1;",
                    "\t/** The number of PeerInteraction objects constructed",
                    "\t *  from the CSV file and held in the rawData list. */",
                    "\tpublic static int numberOfEntries = -1;",
                    "",
                    "",
                    "\t/** Initialize reads through the \"peerInteractions.fa2015.final.csv\"",
                    "\t *  file constructing PeerInteraction objects from each line.",
                    "\t *  It then goes through the list of entry objects it just created ",
                    "\t *  and creates another list of valid entries */",
                    "\tpublic static void initialize() ",
                    "\t{",
                    "\t\tSystem.out.println(\"Calling PeerInteractionsData.initialize()\");",
                    "\t\t\t\t",
                    "\t\trawData = new ArrayList<PeerInteraction>();",
                    "\t\tcleanData = new ArrayList<PeerInteraction>();",
                    "",
                    "\t\tTextIO.readFile(\"./src/peerInteractions.fa2015.final.csv\");",
                    "\t\twhile (!TextIO.eof())",
                    "\t\t\trawData.add(new PeerInteraction(TextIO.getln()));",
                    "",
                    "\t\tfor (PeerInteraction elem : rawData){",
                    "\t\t\tnumberOfEntries++;",
                    "\t\t\tif (elem.valid()){",
                    "\t\t\t\t++numberOfValidEntries;",
                    "\t\t\t\tcleanData.add(elem);",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\t",
                    "\t\tpercentValid = 100*((double)numberOfValidEntries/(double)numberOfEntries);",
                    "\t}",
                    "}",
                    ""
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 52
        },
        {
            "id": "codeyQfoY0",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.text.ParseException;",
                    "import java.text.SimpleDateFormat;",
                    "import java.util.*;",
                    "\t",
                    "/**",
                    "\t *  This class is a simple data structure that represents an entry from the CS125",
                    "\t *  lecture feedback app. It contains a pair of encoded NetIDs, a grade, two",
                    "\t *  feedback strings, and a date string.",
                    "\t *  @author CS125 Research",
                    "\t */",
                    "\tpublic final class PeerInteraction {",
                    "\t\t",
                    "\t\tprivate boolean good = false;",
                    "\t\tprivate int grade = -1;",
                    "\t\tprivate int personID = -1;",
                    "\t\tprivate int partnerID = -1;",
                    "\t\tprivate String strengths;",
                    "\t\tprivate String weaknesses;",
                    "\t\tprivate Date date;",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * Map-less String constructor. Takes an unprocessed line from a CSV",
                    "\t\t * and parses it as a valid PeerInteraction without using an NRList to",
                    "\t\t * verify NetIDs. The constructor marks the entry as bad if the",
                    "\t\t * NetIDs cannot be parsed as integers (It also throws an exception if",
                    "\t\t * the data clearly cannot represent an entry made by a student.",
                    "\t\t * Useful for debugging).",
                    "\t\t * ",
                    "\t\t * @param data An unprocessed line to parse. Must be formatted in the",
                    "\t\t *             form \"netid1\", \"netid2\", \"5\", \"Strengths\",",
                    "\t\t *             \"Weaknesses\", \"Date\";",
                    "\t\t */",
                    "\t\tpublic PeerInteraction(String data){",
                    "\t\t\tgood = true;",
                    "\t\t\tcheckCorruptData(data);",
                    "\t\t\tString[] separated = splitCommas(data);",
                    "\t\t\tfor (int i = 0; i < separated.length; ++i)",
                    "\t\t\t\tseparated[i] = process(separated[i]);",
                    "\t\t\t",
                    "\t\t\t//parse out personID",
                    "\t\t\tpersonID = -1;",
                    "\t\t\ttry{",
                    "\t\t\t\tpersonID = Integer.parseInt(separated[0]);",
                    "\t\t\t}catch(Exception e) {/*Do nothing*/}",
                    "\t\t\t",
                    "\t\t\t//parse out the partnerID",
                    "\t\t\tpartnerID = -1;",
                    "\t\t\ttry{",
                    "\t\t\t\tpartnerID = Integer.parseInt(separated[1]);",
                    "\t\t\t}catch(Exception e) {/*Do nothing*/}",
                    "\t\t\t",
                    "\t\t\t//parse out the grade",
                    "\t\t\tgrade = -1;",
                    "\t\t\ttry{",
                    "\t\t\t\tgrade = Integer.parseInt(separated[2]);",
                    "\t\t\t}catch(Exception e){/*Do nothing*/}",
                    "\t\t\t",
                    "\t\t\t//check validity of parsed values that are critical",
                    "\t\t\tif (personID == -1 || partnerID == -1 || grade > 10 || grade < 1 || ",
                    "\t\t\t    personID == partnerID) {",
                    "\t\t\t\tgood = false;",
                    "\t\t\t}",
                    "\t\t\t",
                    "\t\t\t//parse strengths and weakness optional text",
                    "\t\t\tstrengths = separated[3];",
                    "\t\t\tweaknesses = separated[4];",
                    "\t\t\t",
                    "\t\t\t//create a java date object from the csv file's timestamp",
                    "\t\t\ttry{",
                    "\t\t\t\tdate = new ",
                    "\t\t\t\t    SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\").parse(separated[5]);",
                    "\t\t\t}catch(Exception e) {/*Do nothing*/}",
                    "\t\t}",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * String constructor. Takes an unprocessed line from a CSV file and",
                    "\t\t * parses it as a valid PeerInteraction using a passed-in NRList to",
                    "\t\t * verify NetIDs. The constructor marks the entry as",
                    "\t\t * bad if any NetIDs are missing or do not belong to any students in",
                    "\t\t * the NRList. [It also throws an exception if the data clearly",
                    "\t\t * cannot represent an entry made by a student. Useful for debugging.]",
                    "\t\t *",
                    "\t\t *  @param data  An unprocessed line to parse. Must be formatted in the",
                    "\t\t *               form \"netid1\", \"netid2\", \"5\", \"Strengths\", ",
                    "\t\t *               \"Weaknesses\", \"Date\";",
                    "\t\t *  @param map   A list of all netIDs of students in the class",
                    "\t\t *               and their corresponding codes.",
                    "\t\t */",
                    "\t\tpublic PeerInteraction(String data, NRList map){",
                    "\t\t\tgood = true;",
                    "\t\t\tString[] separated = checkCorruptData(data);",
                    "\t\t\tfor (int i = 0; i < separated.length; ++i)",
                    "\t\t\t\tseparated[i] = process(separated[i]);",
                    "\t\t\tpersonID = map.getSecret(separated[0]);",
                    "\t\t\tpartnerID = map.getSecret(separated[1]);",
                    "\t\t\tgrade = Integer.parseInt(separated[2]);",
                    "\t\t\tif (grade > 10 || grade < 1 || personID == partnerID)",
                    "\t\t\t\tgood = false;",
                    "\t\t\tstrengths = separated[3];",
                    "\t\t\tweaknesses = separated[4];",
                    "\t\t\ttry{",
                    "\t\t\t\tdate = new ",
                    "\t\t\t\t    SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\").parse(separated[5]);",
                    "\t\t\t}catch(Exception e) {/*Do nothing*/}",
                    "\t\t}",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * This merge constructor creates a PeerInteraction whose parameters are",
                    "\t\t * all the same as those of the last valid element in the argument, except",
                    "\t\t * for the written feedback parameters. These parameters are formed",
                    "\t\t * from a processed concatenation of all elements in the argument.",
                    "\t\t * ",
                    "\t\t * @param duplicates An array of PeerInteractions corresponding to the",
                    "\t\t *                   same lecture and having the same personID.",
                    "\t\t */",
                    "\t\tpublic PeerInteraction(PeerInteraction[] duplicates){",
                    "\t\t\tPeerInteraction ref = duplicates[duplicates.length-1];",
                    "\t\t\tfor (int i = duplicates.length; --i >= 0;){",
                    "\t\t\t\tif(duplicates[i].valid()){",
                    "\t\t\t\t\tref =  duplicates[i];",
                    "\t\t\t\t\tbreak;",
                    "\t\t\t\t}",
                    "\t\t\t}",
                    "\t\t\tpersonID = ref.personID;",
                    "\t\t\tpartnerID = ref.partnerID;",
                    "\t\t\tgrade = ref.grade;",
                    "\t\t\tgood = ref.good;",
                    "\t\t\tdate = ref.getDate();",
                    "\t\t\tif (duplicates.length == 1){",
                    "\t\t\t\tstrengths = duplicates[0].strengths;",
                    "\t\t\t\tweaknesses = duplicates[0].weaknesses;",
                    "\t\t\t\treturn;",
                    "\t\t\t}",
                    "\t\t\tStringBuilder strBuild = new StringBuilder();",
                    "\t\t\tStringBuilder weakBuild = new StringBuilder();",
                    "\t\t\tfor (PeerInteraction elem : duplicates){",
                    "\t\t\t\tstrBuild.append('{' + elem.strengths + '}');",
                    "\t\t\t\tweakBuild.append('{' + elem.weaknesses + '}');",
                    "\t\t\t}",
                    "\t\t\tstrengths = strBuild.toString();",
                    "\t\t\tweaknesses = weakBuild.toString();",
                    "\t\t}",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * Returns true if this entry is valid. This implies that both NetID ",
                    "\t\t * codes were entered and actually represent real students and that the ",
                    "\t\t * grade was between 1 and 10 and that the date was a valid date.",
                    "\t\t *",
                    "\t\t *  @return True for valid entries, false for invalid entries.",
                    "\t\t */",
                    "\t\tpublic boolean valid()        {return good;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return How well the student rated this lecture, from 1 to 10.",
                    "\t\t */",
                    "\t\tpublic int     getGrade()     {return grade;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The int code representing the netID of the first person.",
                    "\t\t */",
                    "\t\tpublic int     getPersonID()  {return personID;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The int code representing the netID of the second person.",
                    "\t\t */",
                    "\t\tpublic int     getPartnerID() {return partnerID;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The student's report on what he/she understood from lecture.",
                    "\t\t */",
                    "\t\tpublic String  getStrength()  { return strengths; }",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The student's report on what he/she did not understand from ",
                    "\t\t *          lecture.",
                    "\t\t */",
                    "\t\tpublic String  getWeakness()  { return weaknesses; }",
                    "",
                    "\t\t/**",
                    "\t\t *  @return A copy of the date of this entry.",
                    "\t\t */",
                    "\t\tpublic Date    getDate()      { return new Date(date.getTime()); }",
                    "",
                    "\t\t/**",
                    "\t\t *  Method that indicates whether this entry has any written",
                    "\t\t *  PeerInteraction information at all.",
                    "\t\t *",
                    "\t\t *  @return True if either weaknesses or strengths is nonempty, false",
                    "\t\t *          otherwise.",
                    "\t\t */",
                    "\t\tpublic boolean hasFeedback(){",
                    "\t\t\treturn (strengths.length() > 0 || weaknesses.length() > 0);",
                    "\t\t}",
                    "",
                    "\t\t/**",
                    "\t\t *  Returns a simple but complete representation of this entry. Note",
                    "\t\t *  that invalid entries return \"INVALID ENTRY\". Not for file writing.",
                    "\t\t *",
                    "\t\t *  @return \"INVALID_ENTRY\" for invalid entries or a single-line ",
                    "\t\t * \t\t\trepresentation of all data members of this entry.",
                    "\t\t */",
                    "\t\tpublic String toString(){",
                    "\t\t\tString result = String.format(\"Student: %d Partner: %d Grade: %d \"",
                    "\t\t\t                  + \"Good: \\\"%s\\\" Bad: \\\"%s\\\" Date: %s\", ",
                    "\t\t\t                     personID, partnerID, grade,",
                    "\t\t\t                     strengths, weaknesses, date);",
                    "\t\t\treturn (!good ? \"INVALID ENTRY: \":\"\") + result;",
                    "\t\t}",
                    "\t\t",
                    "\t\t/**",
                    "\t\t *  Checks to see that a line passed into the constructor could possibly",
                    "\t\t *  represent an entry (valid or otherwise) made by a student and stored",
                    "\t\t *  in a CSV file. The method throws an IllegalArgumentException if the",
                    "\t\t *  line is invalid, namely if it doesn't have the right number of",
                    "\t\t *  elements or its elements are not surrounded with quotation marks.",
                    "\t\t *",
                    "\t\t *  @param line The line to be validated. ",
                    "\t\t */",
                    "\t\tprivate String[] checkCorruptData(String line){",
                    "\t\t\tSimpleDateFormat tst = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");",
                    "\t\t\tString[] separated;",
                    "\t\t\ttry{",
                    "\t\t\t\tseparated = splitCommas(line);",
                    "\t\t\t\tDate tmp1 = tst.parse(separated[5]);",
                    "\t\t\t\tint tmp2 = Integer.parseInt(separated[2]);",
                    "\t\t\t}catch(IllegalArgumentException iae){",
                    "\t\t\t\tthrow new ",
                    "\t\t\t\t\tIllegalArgumentException(iae.getMessage() + \": \" + line);",
                    "\t\t\t}",
                    "\t\t\tcatch(IndexOutOfBoundsException ioobe){",
                    "\t\t\t    throw new IllegalArgumentException(\"Too many CSVs: \" + line);",
                    "\t\t\t}",
                    "\t\t\tcatch(ParseException pe){",
                    "\t\t\t\tthrow new ",
                    "\t\t\t\t   IllegalArgumentException(\"Date/Rating parse error: \" + line);",
                    "\t\t\t}",
                    "\t\t\treturn separated;",
                    "\t\t}",
                    "",
                    "\t\t/**",
                    "\t\t * Method that processes written feedback for better representation. ",
                    "\t\t * For example, should remove newlines and leading white spaces.",
                    "\t\t *",
                    "\t\t * @param An unprocessed string of written feedback.",
                    "\t\t * @return A processed string of written feedback.",
                    "\t\t */",
                    "\t\tprivate String process(String unprocessed){",
                    "\t\t\tif (unprocessed.length() == 0)",
                    "\t\t\t\treturn unprocessed;",
                    "\t\t\tunprocessed = unprocessed.replace(\"\\n\", \"\\\\n\"); //Removes newlines",
                    "\t\t\treturn unprocessed.trim();     //Removes trailing/leading whitespace",
                    "\t\t}",
                    "\t",
                    "",
                    "\t\t /**",
                    "\t\t  * Private helper method for constructor. Splits a String into a ",
                    "\t\t  * String[], splitting at (and getting rid of) commas ONLY IF those ",
                    "\t\t  * commas are not enclosed by quotes. Also converts double-double ",
                    "\t\t  * quotes into ordinary double quotes and implicitly throws an ",
                    "\t\t  * exception if the number of partitions is not exactly 6.",
                    "\t\t  *",
                    "\t\t  *  @params input The string to be parsed from a CVS file.",
                    "\t\t  *",
                    "\t\t  *  @return A String array containing the formatted contents of input, ",
                    "\t\t  *          split at commas iff they are enclosed by quotation marks.",
                    "\t\t  */",
                    "\t\tprivate static String[] splitCommas(String input)",
                    "\t\t{",
                    "\t\t\tString[] partitions = new String[6];",
                    "\t\t\tint partition = 0;",
                    "\t\t\tStringBuilder build = new StringBuilder();",
                    "\t\t\tboolean evenQuotes = true;",
                    "\t\t\tboolean lastQuote = false;",
                    "\t\t\tint i = 0;",
                    "\t\t\tchar current = '\\0';",
                    "\t\t\twhile (i < input.length()){",
                    "\t\t\t\tcurrent = input.charAt(i++);",
                    "\t\t\t\tif (current != ',' || !evenQuotes){",
                    "\t\t\t\t\tif (current == '\\\"'){",
                    "\t\t\t\t\t\tevenQuotes = !evenQuotes;",
                    "\t\t\t\t\t\tif (lastQuote && !evenQuotes){",
                    "\t\t\t\t\t\t\tbuild.append(current);",
                    "\t\t\t\t\t\t\tlastQuote = false;",
                    "\t\t\t\t\t\t}else",
                    "\t\t\t\t\t\t\tlastQuote = true;",
                    "\t\t\t\t\t}else if (!evenQuotes){",
                    "\t\t\t\t\t\tbuild.append(current);",
                    "\t\t\t\t\t\tlastQuote = false;",
                    "\t\t\t\t\t}else if (current != ' ')",
                    "\t\t\t\t\t\tthrow new ",
                    "\t\t\t\t\t\t    IllegalArgumentException(\"Garbage between quotes\");",
                    "\t\t\t\t}else{",
                    "\t\t\t\t\tpartitions[partition++] = build.toString();",
                    "\t\t\t\t\tbuild.setLength(0);",
                    "\t\t\t\t\tlastQuote = false;",
                    "\t\t\t\t}",
                    "\t\t\t}",
                    "\t\t\tif (!evenQuotes)",
                    "\t\t\t\tthrow new IllegalArgumentException(\"Missing closing quotes\");",
                    "\t\t\telse if (current == ',' || current == '\\\"')",
                    "\t\t\t\tpartitions[partition++] = build.toString();",
                    "\t\t\tif (partition != 6)",
                    "\t\t\t\tthrow new ",
                    "\t\t\t\t    IllegalArgumentException(\"Only \" + partition + \" CSVs\");",
                    "\t\t\treturn partitions;",
                    "\t\t}",
                    "",
                    "\t/**",
                    "\t *  A test runner for PeerInteraction that reads from a raw CSV file and ",
                    "\t *  constructs corresponding FeedbackEntry objects if possible. The ",
                    "\t *  method then prints out all corrupt lines in the file with their",
                    "\t *  line numbers, all PeerInteraction objects via PeerInteraction.toString(),",
                    "\t *  and finally the number of corrupt and clean lines in the file.",
                    "\t *  The user may opt to use an NRList in this testing. Note that valid",
                    "\t *  entries are required to have integer netID fields if no NRList is",
                    "\t *  used, otherwise the netIDs must both be found in the NRList.",
                    "\t * ",
                    "\t *  @param args Three possibilities::",
                    "\t *              1) *empty*: method prompts user to enter feedback source file ",
                    "\t *                  and (optional) NRList source file",
                    "\t *              2) {encoded feedback source file}: uses the",
                    "\t *                  FeedbackEntry(String) constructor to construct entries",
                    "\t *                  from the given source file (uses no NRList)",
                    "\t *              3) {feedback source file, roster source file}: uses the",
                    "\t *                  FeedbackEntry(String, NRList) constructor to construct",
                    "\t *                  entries from the feedback file and uses the roster",
                    "\t *                  file to create the needed NRList",
                    "\t */ ",
                    "\tpublic static void main(String[] args){",
                    "\t\tString feedbackSrcFile = null;",
                    "\t\tString rosterSrcFile = null;",
                    "\t\tboolean requestRoster = false;",
                    "\t\tswitch (args.length){",
                    "\t\tcase 2: //Set iff argc == 2",
                    "\t\t\trosterSrcFile = args[2]; ",
                    "\t\tcase 1: //Set iff argc == 1 or 2",
                    "\t\t\tfeedbackSrcFile = args[1];",
                    "\t\t\tbreak;",
                    "\t\tcase 0: //Set iff argc == 0",
                    "\t\t\trequestRoster = true;",
                    "\t\t\tbreak;",
                    "\t\tdefault: //Anything else is erroneous",
                    "\t\t\tSystem.out.println(\"Invalid arg count.\");",
                    "\t\t\treturn;",
                    "\t\t}",
                    "\t\tif (feedbackSrcFile == null){",
                    "\t\t\tSystem.out.print(\"Enter feedback source file name: \");",
                    "\t\t\tfeedbackSrcFile = TextIO.getln();",
                    "\t\t}",
                    "\t\tif (requestRoster){",
                    "\t\t\tSystem.out.print(\"Enter YES to use an NRList: \");",
                    "\t\t\tif (TextIO.getln().toUpperCase().equals(\"YES\")){",
                    "\t\t\t\tSystem.out.print(\"Enter roster source file name: \");",
                    "\t\t\t\trosterSrcFile = TextIO.getln();",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tNRList encryptor = null;",
                    "\t\tif (rosterSrcFile != null){",
                    "\t\t\ttry{",
                    "\t\t\t\tencryptor = new NRList(rosterSrcFile, 10000);",
                    "\t\t\t}catch (Exception e){",
                    "\t\t\t\tSystem.out.printf(\"Problem with file: %s\\n\", rosterSrcFile);",
                    "\t\t\t\treturn;",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tString logFile = \"\";",
                    "\t\t//Request log file from user. This functionality is disabled",
                    "\t\t//by the multi-line comments below. Uncomment to create a log ",
                    "\t\t//file. Useful if testing from your own machine.",
                    "\t\t/*",
                    "\t\tSystem.out.println(\"Enter the name of a file to log this test's \"",
                    "\t\t                 + \"results, or enter nothing to skip logging.\");",
                    "\t\tlogFile = TextIO.getln().trim();",
                    "\t\t*/",
                    "\t\tboolean log = false;",
                    "\t\tif (logFile.length() != 0){",
                    "\t\t\tTextIO.writeFile(logFile);",
                    "\t\t\tlog = true;",
                    "\t\t}",
                    "\t\tString temp = \"\";",
                    "\t\tString out = \"\";",
                    "\t\tif (rosterSrcFile != null)",
                    "\t\t    temp = \" using NRList from \" + rosterSrcFile;",
                    "\t\tout = String.format(\"\\n\\nVerifying integrity of %s%s on \" ",
                    "\t\t                  + new Date() + '\\n', feedbackSrcFile, temp);",
                    "\t\tSystem.out.println(out);",
                    "\t\tif (log) TextIO.putln(out); //For compactness and readability",
                    "\t\tTextIO.readFile(feedbackSrcFile);",
                    "\t\t//results",
                    "\t\tint invalid = 0, valid = 0;",
                    "\t\t",
                    "\t\t//testing",
                    "\t\tint line = 0;",
                    "\t\tArrayList<String> failures = new ArrayList<String>();",
                    "\t\twhile (!TextIO.eof()) {",
                    "\t\t\t++line;",
                    "\t\t\tString currentLine = TextIO.getln();",
                    "\t\t\ttry {",
                    "\t\t\t\t//Call appropriate constructor",
                    "\t\t\t\tPeerInteraction test = (encryptor == null) ?",
                    "\t\t\t\t    new PeerInteraction(currentLine) :",
                    "\t\t\t\t    new PeerInteraction(currentLine, encryptor);",
                    "\t\t\t\t++valid;",
                    "\t\t\t\tout = test.toString();",
                    "\t\t\t\tSystem.out.println(out);",
                    "\t\t\t\tif (log) TextIO.putln(out);",
                    "\t\t\t} catch(IllegalArgumentException e){",
                    "\t\t\t\t++invalid;",
                    "\t\t\t\tout = String.format(\"Line %d: %s\\n\", line, e.getMessage());",
                    "\t\t\t\tfailures.add(out);",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tif (failures.size() != 0 && log){\t\t\t",
                    "\t\t\tTextIO.putf(\"\\n\\nWARNING: %d CORRUPT LINES!\\n\\n\\n\", failures.size());",
                    "\t\t}",
                    "\t\tfor (String elem : failures){",
                    "\t\t\tSystem.out.print(elem);",
                    "\t\t\tif (log) TextIO.put(elem);",
                    "\t\t}",
                    "\t\tout = String.format(\"\\n\\nThere were %d clean and %d corrupt lines.\\n\", ",
                    "\t\t                    valid, invalid);",
                    "\t\tSystem.out.println(out);",
                    "\t\tif (log) TextIO.putln(out);",
                    "\t\tSystem.out.println(\"Done.\");",
                    "\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 426
        },
        {
            "id": "code72DPAE",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.Arrays;",
                    "",
                    "/**",
                    " * A simple pair POD that couples an integer ID code with ",
                    " * a NetID and stores the two for use in encrypting data.",
                    " * @author CS125Research",
                    " */",
                    "public class NetIDPair {",
                    "\tprivate String netID;",
                    "\tprivate int code;",
                    "\t",
                    "\t/**",
                    "\t * Struct constructor.",
                    "\t * ",
                    "\t * @param newNetid  NetID of student.",
                    "\t * @param newCode   Code associated with this NetID.",
                    "\t */",
                    "\tpublic NetIDPair(String newNetID, int newCode){",
                    "\t\tnetID = newNetID;",
                    "\t\tcode = newCode;\t",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The code associated with this netID.",
                    "\t */\t",
                    "\tpublic int getCode() { return code; }",
                    "\t",
                    "\t/**",
                    "\t * @return The string representation of this pair. Just a comma",
                    " \t *         separated juxtaposition of netID and code.",
                    "\t */",
                    "\tpublic String toString(){",
                    "\t\tchar[] build = new char[netID.length()];",
                    "\t\tArrays.fill(build, '*');",
                    "\t\tbuild[0] = netID.charAt(0);",
                    "\t\tint last = netID.length()-1;",
                    "\t\tbuild[last] = netID.charAt(last);",
                    "\t\treturn (new String(build)) + \": \" + code;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return True iff searchID matches this NetIDPair's netID.",
                    "\t */",
                    "\tpublic boolean equals(String searchID){",
                    "\t\treturn this.netID.equals(searchID);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return True iff other.netID matches this NetIDPair's netID.",
                    "\t */",
                    "\tpublic boolean equals(NetIDPair other){",
                    "\t\treturn this.netID.equals(other.netID);",
                    "\t}",
                    "\t",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 55
        },
        {
            "id": "codeeKyrgh",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.ArrayList;",
                    "import java.util.Collections;",
                    "import java.util.Iterator;",
                    "/**",
                    " *  A simple map-like list of NetIDPairs with a file argument constructor.",
                    " *  Can return the code associated with a particular netID passed into its",
                    " *  getSecret() method.",
                    " *  @author CS125Research",
                    " */",
                    "public class NRList implements Iterable<NetIDPair>{",
                    "\t",
                    "\t/* A list of all NetIDPairs extracted from the roster */",
                    "\tprivate ArrayList <NetIDPair> pairList = new ArrayList<NetIDPair>();",
                    "\t/* The maximum allowable size of this NRList */",
                    "\tprivate int capacity;",
                    "\t",
                    "\t/**",
                    "\t * String collection constructor. Takes an ArrayList of netIDs and then",
                    "\t * makes a NRList from these netIDs, randomly assigning netIDs to codes in",
                    "\t * the interval [0, range-1]. ",
                    "\t * ",
                    "\t * @param netIDs The collection of netIDs used to form the NRList.",
                    "\t * @param range  Range element for NetIDPair random generator.",
                    "\t */",
                    "\tpublic NRList(Iterable<String> netIDs, int range){",
                    "\t\tcapacity = range;",
                    "\t\tfor (String elem : netIDs)",
                    "\t\t\taddPair(elem);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * File argument constructor. Reads input file and fills up data",
                    "\t * structure with NetIDPair objects from the file. The codes of these",
                    "\t * NetIDPairs will be in the interval [0, range-1].",
                    "\t *",
                    "\t * @param inFile  The name of the file from which we read netIDs.",
                    "\t * @param range   Range element for NetIDPair random generator.",
                    "\t */",
                    "\tpublic NRList(String inFile, int range){",
                    "\t\tcapacity = range;",
                    "\t\tfillList(inFile);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Helper function for constructor that does all the work.",
                    "\t * Takes in filenames to get a source of NetIDs and a",
                    "\t * range to determine the range of ID codes assigned. Also used",
                    "\t * to add new NetIDPairs to an existing NRList.",
                    "\t * ",
                    "\t * @param readFilePath The source file for all netIDs.",
                    "\t */",
                    "\tpublic void fillList(String readFilePath)",
                    "\t{",
                    "\t\tTextIO.readFile(readFilePath);\t\t",
                    "\t\twhile(!TextIO.eof())",
                    "\t\t{",
                    "\t\t\tString line = TextIO.getln();",
                    "\t\t\tString netID = line.split(\",\")[1];",
                    "\t\t\taddPair(netID);",
                    "\t\t}",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Adds a NetIDPair object to this NRList whose netID field",
                    "\t * matches the argument of this method. The NRList must not",
                    "\t * already be at full capacity or an exception will be thrown.",
                    "\t *  ",
                    "\t * @param netID The netID of the NetIDPair to be added to this NRList.",
                    "\t */",
                    "\tpublic void addPair(String netID){",
                    "\t\tNetIDPair potentialPair = null;",
                    "\t\tif (pairList.size() == capacity)",
                    "\t\t\tthrow new IndexOutOfBoundsException(\"NRList is full.\");",
                    "\t\tdo{",
                    "\t\t\tint randomID = (int) (Math.random()*capacity);",
                    "\t\t\tpotentialPair = new NetIDPair(netID,randomID);",
                    "\t\t} while(check(potentialPair));",
                    "\t\tpairList.add(potentialPair);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The number of NetIDPairs in this NRList. ",
                    "\t */",
                    "\tpublic int size(){",
                    "\t\treturn pairList.size();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The maximum allowed number of NetIDPairs in this NRList.",
                    "\t */",
                    "\tpublic int capacity(){",
                    "\t\treturn capacity;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t *  Private helper function that searches the NRList to ensure that",
                    "\t *  no two NetIDPair instances therein correspond to the same code",
                    "\t *  or netID.",
                    "\t *",
                    "\t *  @param potentialPair  A potential NetIDPair that may be added to the list.",
                    "\t *  @return True if the code of potentialPair isn't already found in",
                    "\t *          the NRList.",
                    "\t */",
                    "\tprivate boolean check(NetIDPair potentialPair){",
                    "\t\tfor (NetIDPair elem : pairList){",
                    "\t\t\tif (elem.equals(potentialPair)){",
                    "\t\t\t\tthrow new IllegalArgumentException(",
                    "\t\t\t\t    \"Attempted to add existing netID to this Roster.\");",
                    "\t\t\t}",
                    "\t\t\tif (elem.getCode() == potentialPair.getCode())",
                    "\t\t\t\treturn true;",
                    "\t\t}",
                    "\t\treturn false;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t *  Returns the code corresponding to a given netID.",
                    "\t *  ",
                    "\t *  @param netID  The netID whose code is being searched.",
                    "\t *  @return  The code of the netID argument if it is found or -1 otherwise.",
                    "\t */",
                    "\tpublic int getSecret(String netID)",
                    "\t{",
                    "\t\tfor(NetIDPair elem : pairList)",
                    "\t\t\tif (elem.equals(netID))",
                    "\t\t\t\treturn elem.getCode();",
                    "\t\treturn -1;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Prints out the contents of this NRList separated by",
                    "\t * newlines.",
                    "\t */",
                    "\tpublic void printList() {",
                    "\t\tfor (int i = 0; i < pairList.size(); i++) {",
                    "\t\t\tSystem.out.println(pairList.get(i));",
                    "\t\t}",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return an iterator to the start of this NRList.",
                    "\t */",
                    "\tpublic Iterator<NetIDPair> iterator() { return pairList.iterator(); }",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 144
        },
        {
            "id": "code4HC8c6",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.text.SimpleDateFormat;",
                    "import java.util.ArrayList;",
                    "import java.util.Date;",
                    "",
                    "public class LectureData {",
                    "\t\t///TODO - document these properties",
                    "\t\tpublic static double mean, stdDev;",
                    "\t\tpublic static ArrayList<Lecture> lectures;",
                    "\t\t",
                    "\t\t///TODO - document this method",
                    "\t\tpublic static void initialize() {",
                    "\t\t\tSystem.out.println(\"Calling LectureData.initialize()\");",
                    "\t\t\t",
                    "\t\t\tlectures = new ArrayList<>();",
                    "\t\t\tint[] months = {9,  9,  9,  9,  9,   9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12};",
                    "\t\t\tint[] days =   {18, 21, 23, 25, 28, 30, 2 ,  5,  7,  9, 12, 14, 16, 19, 21, 23, 26, 28, 30, 02, 04, 06, 9,  11, 13, 16, 18, 20, 30, 2,   4,  7,  9, 31};",
                    "\t\t\tDate[] lectureDates = new Date[months.length];",
                    "\t\t\ttry {",
                    "\t\t\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");",
                    "\t\t\t\tfor (int i = 0; i < months.length; ++i){",
                    "\t\t\t\t\tString toParse = String.format(\"%d-%d-%02d 09:00:00\", 2015, months[i], days[i]);",
                    "\t\t\t\t\tlectureDates[i] = df.parse(toParse);",
                    "\t\t\t\t}",
                    "\t\t\t} catch(Exception e){",
                    "\t\t\t\te.printStackTrace();",
                    "\t\t\t}",
                    "\t\t\tint currTimeIndex = 0;",
                    "\t\t\tdouble sum = 0;",
                    "\t\t\tdouble sumSq = 0;",
                    "\t\t\tint counter = 0;",
                    "\t\t\t",
                    "\t\t\tArrayList<PeerInteraction> cleanedData = PeerInteractionsData.cleanData;",
                    "\t\t\tfor(int i = 0; i < cleanedData.size(); i++){",
                    "\t\t\t",
                    "\t\t\t\twhile(cleanedData.get(i).getDate().after(lectureDates[currTimeIndex + 1]))",
                    "\t\t\t\t\tcurrTimeIndex++;",
                    "\t\t\t\t",
                    "\t\t\t\taddToLecture(lectureDates[currTimeIndex], cleanedData.get(i));",
                    "\t\t\t\tdouble temp = cleanedData.get(i).getGrade();",
                    "\t\t\t\tsum += temp;",
                    "\t\t\t\tsumSq += temp*temp;",
                    "\t\t\t\t++counter;",
                    "\t\t\t}",
                    "\t\t\t",
                    "\t\t\tmean = sum/counter;",
                    "\t\t\tstdDev = Math.sqrt(sumSq/counter - sum*sum/(counter*counter));",
                    "\t\t}",
                    "\t\t",
                    "\t\tprivate static void addToLecture(Date d, PeerInteraction entry){",
                    "\t\t\tif(lectures.size()>0 && lectures.get(lectures.size()-1).getDate().equals(d)){",
                    "\t\t\t\tlectures.get(lectures.size()-1).add(entry);",
                    "\t\t\t} else {",
                    "\t\t\t\tlectures.add(new Lecture(d, entry));",
                    "\t\t\t}\t",
                    "\t\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "state": {},
                "height": 56
            },
            "evaluatorReader": true,
            "lineCount": 56
        },
        {
            "id": "code9Tq9P9",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.text.SimpleDateFormat;",
                    "import java.text.ParseException;",
                    "import java.util.ArrayList;",
                    "import java.util.Date;",
                    "import java.util.*;",
                    "",
                    "/**",
                    " * A model for a lecture object with a unique id corresponding to the lecture number, all the associated peer interactions, the date, and the lecture topics.",
                    " * This class also contains static properties and methods involved with initializing lectures and analyzing the result.",
                    " * @author CS125Research",
                    " */",
                    "public class Lecture implements Iterable<PeerInteraction>{",
                    "",
                    "\tprivate static int AUTO_INCREMENT = 0;",
                    "\tprivate int lectureNumber; //TODO: Discuss this name",
                    "\tpublic ArrayList<PeerInteraction> recordsByTime;",
                    "\tprivate Date date;",
                    "\tprivate String[] topics;// OR ArrayList<String>",
                    "\t",
                    "\t/**",
                    "\t * Base constructor called by all other constructors.",
                    "\t * Assigns a Date to this Lecture object.",
                    "\t * ",
                    "\t * @param d The time this lecture began.",
                    "\t */",
                    "\tpublic Lecture(Date d){",
                    "\t\tlectureNumber = AUTO_INCREMENT++;",
                    "\t\trecordsByTime = new ArrayList<PeerInteraction>();",
                    "\t\tdate = new Date(d.getTime());",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Constructor with argument to assign the topics for",
                    "\t * the Lecture object.",
                    "\t * ",
                    "\t * @param d     The time this lecture began.",
                    "\t * @param topic A list of topics discussed during this lecture.",
                    "\t */",
                    "\tpublic Lecture(Date d, String[] topics){",
                    "\t\tthis(d);",
                    "\t\tthis.topics = topics.clone();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Constructor with argument to assign the topics for",
                    "\t * the Lecture object.",
                    "\t * ",
                    "\t * @param d     The time this lecture began.",
                    "\t * @param entry A PeerInteraction that was submitted for this Lecture",
                    "\t */",
                    "\tpublic Lecture(Date d, PeerInteraction entry){",
                    "\t\tthis(d);",
                    "\t\tthis.add(entry);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return the lecture number.",
                    "\t */",
                    "\tpublic int getLectureNumber(){",
                    "\t\treturn lectureNumber;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return A copy of this Lecture's date.",
                    "\t */",
                    "\tpublic Date getDate(){",
                    "\t\treturn new Date(date.getTime());",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * This method adds a PeerInteraction to this Lecture. As a ",
                    "\t * precondition, entries should be added in chronological ",
                    "\t * order.",
                    "\t * ",
                    "\t * @param entry The entry to add to this Lecture. This entry should",
                    "\t *              come after the last entry added to the Lecture.",
                    "\t */",
                    "\tpublic void add(PeerInteraction entry){",
                    "\t\trecordsByTime.add(entry);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Static method that uses a right-biased binary search of existing Lectures",
                    "\t * to associate a PeerInteraction with a Lecture. Runs in logarithmic time with",
                    "\t * respect to the number of Lectures.",
                    "\t *",
                    "\t * @param key The entry to be associated with a Lecture.",
                    "\t *",
                    "\t * @return The Lecture corresponding to an entry.",
                    "\t */",
                    "\tpublic static Lecture get(PeerInteraction key){",
                    "\t\tArrayList<Lecture> lecs = LectureData.lectures;",
                    "\t\tint lo = 0;",
                    "\t\tint hi = lecs.size()-1;",
                    "\t\tDate search = key.getDate();",
                    "\t\twhile (hi != lo){",
                    "\t\t\tint mid = (lo + hi + 1)/2;",
                    "\t\t\tDate comp = lecs.get(mid).getDate();",
                    "\t\t\tswitch (search.compareTo(comp)){",
                    "\t\t\tcase -1:",
                    "\t\t\t\thi = mid-1; break; //Can exclude Dates that come after target",
                    "\t\t\tcase 1:",
                    "\t\t\t\tlo = mid; break;  //Can't exclude Dates that come before",
                    "\t\t\tdefault:",
                    "\t\t\t\treturn lecs.get(mid); //Unlikely case of exact match",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\treturn lecs.get(lo);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Method that returns the unadjusted rating distribution of all",
                    "\t * PeerInteractions for this Lecture. The 0th element of this",
                    "\t * array corresponds to the number of entries with ratings of",
                    "\t * 1, and the 9th to the number of entries with ratings of 10.",
                    "\t * ",
                    "\t * @return An array of ints in which arr[idx] represents the number",
                    "\t *         of PeerInteractions with ratings of (idx+1) in this Lecture",
                    "\t */",
                    "\tpublic int[] ratingDistribution() {",
                    "\t\tint[] values = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};",
                    "\t\tfor (PeerInteraction element : recordsByTime)",
                    "\t\t\tvalues[element.getGrade() - 1]++;",
                    "\t\treturn values;",
                    "\t}",
                    "\t",
                    "\tpublic String ratingDistributionString() {",
                    "\t\tString stringRepresentation = \"\";",
                    "\t\tint[] distribution = ratingDistribution();",
                    "\t\tfor(int i = 0; i < distribution.length; i++)",
                    "\t\t\tstringRepresentation += ((i + 1) + \": \" + distribution[i] + \", \");",
                    "\t\treturn stringRepresentation;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Calculates and returns the unadjusted average rating given by",
                    "\t * all PeerInteractions for this lecture.",
                    "\t * ",
                    "\t * @return The average rating of all PeerInteractions in this Lecture",
                    "\t */",
                    "\tpublic double ratingMean(){",
                    "\t\tif (recordsByTime.isEmpty())",
                    "\t\t\treturn -1;",
                    "\t\tdouble sum = 0;",
                    "\t\tfor (PeerInteraction element : recordsByTime)",
                    "\t\t\tsum += element.getGrade();",
                    "\t\treturn sum/recordsByTime.size();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Calculates and returns the unadjusted standard deviation of ratings",
                    "\t * given by all PeerInteractions for this lecture.",
                    "\t * ",
                    "\t * @return The rating standard deviation of all PeerInteractions in this ",
                    "\t *         Lecture",
                    "\t */",
                    "\tpublic double ratingStdDev(){",
                    "\t\tif (recordsByTime.isEmpty())",
                    "\t\t\treturn -1;",
                    "\t\tdouble devSq = 0;",
                    "\t\tdouble mean = ratingMean();",
                    "\t\tfor (PeerInteraction element : recordsByTime)",
                    "\t\t\tdevSq += Math.pow(element.getGrade()-mean,2);",
                    "\t\treturn Math.sqrt(devSq/recordsByTime.size());",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The number of PeerInteractions in this Lecture.",
                    "\t */",
                    "\tpublic int entryCount(){",
                    "\t\treturn recordsByTime.size();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return A string in the form \"ID: %, Date: %, Number of Entries: %,\"",
                    "\t *         \"Mean: %, Standard Deviation: %\"",
                    "\t */",
                    "\tpublic String toString(){",
                    "\t\treturn String.format(\"ID: %d\\n\\tDate: \", lectureNumber) + date",
                    "\t\t+ String.format(\"\\n\\tNumber of Entries: %d\\n\\t\"",
                    "\t\t    + \"Mean: %f\\n\\tStandard Deviation: %f\",",
                    "\t\t    recordsByTime.size(), ratingMean(), ratingStdDev())",
                    "\t\t+ \"\\n\\t Rating Distribution: \" + ratingDistributionString();\t",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return A chronological iterator through all PeerInteractions in",
                    "\t *         this Lecture.",
                    "\t */",
                    "\tpublic FeedbackIterator iterator() { return new FeedbackIterator(); }",
                    "\t",
                    "\t/**",
                    "\t * Iterator that goes through FeedbackEntries in chronological order.",
                    "\t */",
                    "\tpublic class FeedbackIterator implements Iterator<PeerInteraction>{",
                    "\t\tprivate int curr;",
                    "\t\t",
                    "\t\tpublic FeedbackIterator()    { curr = 0; }",
                    "\t\tpublic PeerInteraction next()  { return recordsByTime.get(curr++); }",
                    "\t\tpublic boolean hasNext()     { return curr < recordsByTime.size(); }",
                    "\t\tpublic void remove()  { throw new UnsupportedOperationException(); }",
                    "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t",
                    "\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "hidden": true,
                "height": 51
            },
            "evaluatorReader": true,
            "lineCount": 204,
            "tags": "Lecture"
        },
        {
            "id": "sectionxMdttn",
            "type": "section",
            "title": "Runner",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "markdownquMZ68",
            "type": "markdown",
            "body": [
                "This runs Main"
            ],
            "evaluatorReader": false
        },
        {
            "id": "MainRunner",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.ArrayList;",
                    "",
                    "/**",
                    " * The runner class",
                    " * @author CS125Research",
                    " */",
                    "public class Main {",
                    "",
                    "\tpublic static boolean buildSucceeded = false;",
                    "\t",
                    "\tpublic static void main(String[] args) {",
                    "\t\tPeerInteractionsData.initialize();",
                    "\t\tSystem.out.printf(\"Percentage of entries valid: %f%%\\nNumber of valid entries: %d\\nNumber of entries: %d\\n\", PeerInteractionsData.percentValid, PeerInteractionsData.numberOfValidEntries, PeerInteractionsData.numberOfEntries);",
                    "\t\tSystem.out.println(\"======================================================================================\\n\");",
                    "\t\t",
                    "\t\tLectureData.initialize();",
                    "\t\t",
                    "\t\t//Print each lecture object:",
                    "\t\tArrayList<Lecture> lectures = LectureData.lectures;",
                    "\t\tfor(int j = 0; j < lectures.size(); j++) {",
                    "\t\t\tSystem.out.println(lectures.get(j));",
                    "\t\t}",
                    "\t\t",
                    "\t\t//Print stats:",
                    "\t\tSystem.out.printf(\"Average: %f, Standard Deviation: %f\\n\", LectureData.mean, LectureData.stdDev);",
                    "\t\tSystem.out.println(\"Number of lectures: \" + lectures.size());",
                    "\t\tSystem.out.println(\"======================================================================================\\n\");",
                    "\t\tSystem.out.println(\"BUILD FINISHED\");",
                    "\t\tbuildSucceeded = true;",
                    "\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Text",
                    "object": "pending"
                },
                "selectedType": "BeakerDisplay",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 592,
                "height": 0
            },
            "evaluatorReader": true,
            "lineCount": 31
        }
    ],
    "namespace": {}
}
