{
    "beaker": "2",
    "evaluators": [
        {
            "name": "Html",
            "plugin": "Html",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "jsSetting2": "",
            "jsSetting1": "",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            }
        },
        {
            "name": "Java",
            "plugin": "Java",
            "imports": "com.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*",
            "view": {
                "cm": {
                    "mode": "text/x-java"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "sectionkSa6qT",
            "type": "section",
            "title": "Initializing Data Classes",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": false,
            "initialization": true
        },
        {
            "id": "sectionqpRoyN",
            "type": "section",
            "title": "TextIO",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "TextIO",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "",
                    "",
                    "import java.io.*;",
                    "import java.util.IllegalFormatException;",
                    "import java.util.regex.Matcher;",
                    "import java.util.regex.Pattern;",
                    "",
                    "import javax.swing.JFileChooser;",
                    "import javax.swing.JOptionPane;",
                    "",
                    "/**",
                    " * TextIO provides a set of static methods for reading and writing text.  By default, it reads",
                    " * from standard input and writes to standard output, but it is possible to redirect the input",
                    " * and output to files or to other input and output streams.  When the standard input and output",
                    " * streams are being used, the input methods will not produce an error; instead, the user is",
                    " * repeatedly prompted for input until a legal input is entered.  (If standard input has been",
                    " * changed externally, as by file redirection on the command line, this is not a reasonable",
                    " * behavior; to handle this case, TextIO will give up after 10 consecutive illegal inputs and",
                    " * will throw an IllegalArgumentException.)  For the most part, any other",
                    " * error will be translated into an IllegalArguementException.",
                    " * <p>For writing to standard output, the output methods in this class pretty much",
                    " * duplicate the functionality of System.out, and System.out can be used interchangeably with them.",
                    " * <p>This class does not use optimal Java programming practices.  It is designed specifically to be easily",
                    " * usable even by a beginning programmer who has not yet learned about objects and exceptions.  Therefore, ",
                    " * everything is in a single source file that compiles into a single class file, all the methods are",
                    " * static methods, and none of the methods throw exceptions that would require try...catch statements.",
                    " * Also for this reason, all exceptions are converted into IllegalArgumentExceptions, even when this",
                    " * exception type doesn't really make sense.",
                    " * <p>This class requires Java 5.0 or higher. (A previous version of TextIO required only Java 1.1;",
                    " * this version should work with any source code that used the previous version, but it has some new",
                    " * features, including the type of formatted output that was introduced in Java 5 and the ability to",
                    " * use files and streams.)",
                    " */",
                    "public class TextIO {",
                    "",
                    "    /* Modified November 2007 to empty the TextIO input buffer when switching from one",
                    "     * input source to another. This fixes a bug that allows input from the previous input",
                    "     * source to be read after the new source has been selected.",
                    "     */",
                    "",
                    "    /**",
                    "     * The value returned by the peek() method when the input is at end-of-file.",
                    "     * (The value of this constant is (char)0xFFFF.)",
                    "     */",
                    "    public final static char EOF = (char)0xFFFF; ",
                    "",
                    "    /**",
                    "     * The value returned by the peek() method when the input is at end-of-line.",
                    "     * The value of this constant is the character '\\n'.",
                    "     */",
                    "    public final static char EOLN = '\\n';          // The value returned by peek() when at end-of-line.",
                    "    ",
                    "",
                    "    /**",
                    "     * After this method is called, input will be read from standard input (as it ",
                    "     * is in the default state).  If a file or stream was previously the input source, that file",
                    "     * or stream is closed.",
                    "     */",
                    "    public static void readStandardInput() {",
                    "        if (readingStandardInput)",
                    "            return;",
                    "        try {",
                    "            in.close();",
                    "        }",
                    "        catch (Exception e) {",
                    "        }",
                    "        emptyBuffer();  // Added November 2007",
                    "        in = standardInput;",
                    "        inputFileName = null;",
                    "        readingStandardInput = true;",
                    "        inputErrorCount = 0;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, input will be read from inputStream, provided it",
                    "     * is non-null.  If inputStream is null, then this method has the same effect",
                    "     * as calling readStandardInput(); that is, future input will come from the",
                    "     * standard input stream.",
                    "     */",
                    "    public static void readStream(InputStream inputStream) {",
                    "        if (inputStream == null)",
                    "            readStandardInput();",
                    "        else",
                    "            readStream(new InputStreamReader(inputStream));",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, input will be read from inputStream, provided it",
                    "     * is non-null.  If inputStream is null, then this method has the same effect",
                    "     * as calling readStandardInput(); that is, future input will come from the",
                    "     * standard input stream.",
                    "     */",
                    "    public static void readStream(Reader inputStream) {",
                    "        if (inputStream == null)",
                    "            readStandardInput();",
                    "        else {",
                    "            if ( inputStream instanceof BufferedReader)",
                    "                in = (BufferedReader)inputStream;",
                    "            else",
                    "                in = new BufferedReader(inputStream);",
                    "            emptyBuffer();  // Added November 2007",
                    "            inputFileName = null;",
                    "            readingStandardInput = false;",
                    "            inputErrorCount = 0;",
                    "        }",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Opens a file with a specified name for input.  If the file name is null, this has",
                    "     * the same effect as calling readStandardInput(); that is, input will be read from standard",
                    "     * input.  If an",
                    "     * error occurs while trying to open the file, an exception of type IllegalArgumentException",
                    "     * is thrown, and the input source is not changed.  If the file is opened ",
                    "     * successfully, then after this method is called, all of the input routines will read ",
                    "     * from the file, instead of from standard input.",
                    "     */",
                    "    public static void readFile(String fileName) {",
                    "        if (fileName == null) // Go back to reading standard input",
                    "            readStandardInput();",
                    "        else {",
                    "            BufferedReader newin;",
                    "            try {",
                    "                newin = new BufferedReader( new FileReader(fileName) );",
                    "            }",
                    "            catch (Exception e) {",
                    "                throw new IllegalArgumentException(\"Can't open file \\\"\" + fileName + \"\\\" for input.\\n\"",
                    "                                 + \"(Error :\" + e + \")\");",
                    "            }",
                    "            if (! readingStandardInput) { // close current input stream",
                    "                try {",
                    "                    in.close();",
                    "                }",
                    "                catch (Exception e) {",
                    "                }",
                    "            }",
                    "            emptyBuffer();  // Added November 2007",
                    "            in = newin;",
                    "            readingStandardInput = false;",
                    "            inputErrorCount = 0;",
                    "            inputFileName = fileName;",
                    "        }",
                    "    }",
                    "",
                    "    /**",
                    "     * Puts a GUI file-selection dialog box on the screen in which the user can select",
                    "     * an input file.  If the user cancels the dialog instead of selecting a file, it is",
                    "     * not considered an error, but the return value of the subroutine is false.",
                    "     * If the user does select a file, but there is an error while trying to open the",
                    "     * file, then an exception of type IllegalArgumentException is thrown.  Finally, if",
                    "     * the user selects a file and it is successfully opened, then the return value of the",
                    "     * subroutine is true, and  the input routines will read from the file, instead of ",
                    "     * from standard input.   If the user cancels, or if any error occurs, then the",
                    "     * previous input source is not changed.",
                    "     * <p>NOTE: Calling this method starts a GUI user interface thread, which can continue",
                    "     * to run even if the thread that runs the main program ends.  If you use this method",
                    "     * in a non-GUI program, it might be necessary to call System.exit(0) at the end of the main() ",
                    "     * routine to shut down the Java virtual machine completely.",
                    "     */",
                    "    public static boolean readUserSelectedFile() {",
                    "        if (fileDialog == null)",
                    "            fileDialog = new JFileChooser();",
                    "        fileDialog.setDialogTitle(\"Select File for Input\");",
                    "        int option = fileDialog.showOpenDialog(null);",
                    "        if (option != JFileChooser.APPROVE_OPTION)",
                    "            return false;",
                    "        File selectedFile = fileDialog.getSelectedFile();",
                    "        BufferedReader newin;",
                    "        try {",
                    "            newin = new BufferedReader( new FileReader(selectedFile) );",
                    "        }",
                    "        catch (Exception e) {",
                    "            throw new IllegalArgumentException(\"Can't open file \\\"\" + selectedFile.getName() + \"\\\" for input.\\n\"",
                    "                             + \"(Error :\" + e + \")\");",
                    "        }",
                    "        if (!readingStandardInput) { // close current file",
                    "            try {",
                    "                in.close();",
                    "            }",
                    "            catch (Exception e) {",
                    "            }",
                    "        }",
                    "        emptyBuffer();  // Added November 2007",
                    "        in = newin;",
                    "        inputFileName = selectedFile.getName();",
                    "        readingStandardInput = false;",
                    "        inputErrorCount = 0;",
                    "        return true;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, output will be written to standard output (as it ",
                    "     * is in the default state).  If a file or stream was previously open for output, it",
                    "     * will be closed.",
                    "     */",
                    "    public static void writeStandardOutput() {",
                    "        if (writingStandardOutput)",
                    "            return;",
                    "        try {",
                    "            out.close();",
                    "        }",
                    "        catch (Exception e) {",
                    "        }",
                    "        outputFileName = null;",
                    "        outputErrorCount = 0;",
                    "        out = standardOutput;",
                    "        writingStandardOutput = true;",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * After this method is called, output will be sent to outputStream, provided it",
                    "     * is non-null.  If outputStream is null, then this method has the same effect",
                    "     * as calling writeStandardOutput(); that is, future output will be sent to the",
                    "     * standard output stream.",
                    "     */",
                    "    public static void writeStream(OutputStream outputStream) {",
                    "        if (outputStream == null)",
                    "            writeStandardOutput();",
                    "        else",
                    "            writeStream(new PrintWriter(outputStream));",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, output will be sent to outputStream, provided it",
                    "     * is non-null.  If outputStream is null, then this method has the same effect",
                    "     * as calling writeStandardOutput(); that is, future output will be sent to the",
                    "     * standard output stream.",
                    "     */",
                    "    public static void writeStream(PrintWriter outputStream) {",
                    "        if (outputStream == null)",
                    "            writeStandardOutput();",
                    "        else {",
                    "            out = outputStream;",
                    "            outputFileName = null;",
                    "            outputErrorCount = 0;",
                    "            writingStandardOutput = false;",
                    "        }",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * Opens a file with a specified name for output.  If the file name is null, this has",
                    "     * the same effect as calling writeStandardOutput(); that is, output will be sent to standard",
                    "     * output.  If an",
                    "     * error occurs while trying to open the file, an exception of type IllegalArgumentException",
                    "     * is thrown.  If the file is opened successfully, then after this method is called,",
                    "     * all of the output routines will write to the file, instead of to  standard output.",
                    "     * If an error occurs, the output destination is not changed.",
                    "     * <p>NOTE: Calling this method starts a GUI user interface thread, which can continue",
                    "     * to run even if the thread that runs the main program ends.  If you use this method",
                    "     * in a non-GUI program, it might be necessary to call System.exit(0) at the end of the main() ",
                    "     * routine to shut down the Java virtual machine completely.",
                    "     */",
                    "    public static void writeFile(String fileName) {",
                    "        if (fileName == null)  // Go back to reading standard output",
                    "            writeStandardOutput();",
                    "        else {",
                    "            PrintWriter newout;",
                    "            try {",
                    "                newout = new PrintWriter(new FileWriter(fileName));",
                    "            }",
                    "            catch (Exception e) {",
                    "                throw new IllegalArgumentException(\"Can't open file \\\"\" + fileName + \"\\\" for output.\\n\"",
                    "                                 + \"(Error :\" + e + \")\");",
                    "            }",
                    "            if (!writingStandardOutput) {",
                    "                try {",
                    "                    out.close();",
                    "                }",
                    "                catch (Exception e) {",
                    "                }",
                    "            }",
                    "            out = newout;",
                    "            writingStandardOutput = false;",
                    "            outputFileName = fileName;",
                    "            outputErrorCount = 0;",
                    "        }",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Puts a GUI file-selection dialog box on the screen in which the user can select",
                    "     * an output file.  If the user cancels the dialog instead of selecting a file, it is",
                    "     * not considered an error, but the return value of the subroutine is false.",
                    "     * If the user does select a file, but there is an error while trying to open the",
                    "     * file, then an exception of type IllegalArgumentException is thrown.  Finally, if",
                    "     * the user selects a file and it is successfully opened, then the return value of the",
                    "     * subroutine is true, and  the output routines will write to the file, instead of ",
                    "     * to standard output.  If the user cancels, or if an error occurs, then the current",
                    "     * output destination is not changed.",
                    "     */",
                    "    public static boolean writeUserSelectedFile() {",
                    "        if (fileDialog == null)",
                    "            fileDialog = new JFileChooser();",
                    "        fileDialog.setDialogTitle(\"Select File for Output\");",
                    "        File selectedFile;",
                    "        while (true) {",
                    "            int option = fileDialog.showSaveDialog(null);",
                    "            if (option != JFileChooser.APPROVE_OPTION)",
                    "                return false;  // user canceled",
                    "            selectedFile = fileDialog.getSelectedFile();",
                    "            if (selectedFile.exists()) {",
                    "                int response = JOptionPane.showConfirmDialog(null,",
                    "                        \"The file \\\"\" + selectedFile.getName() + \"\\\" already exists.  Do you want to replace it?\",",
                    "                        \"Replace existing file?\",",
                    "                        JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);",
                    "                if (response == JOptionPane.YES_OPTION)",
                    "                    break;",
                    "            }",
                    "            else {",
                    "                break;",
                    "            }",
                    "        }",
                    "        PrintWriter newout;",
                    "        try {",
                    "            newout = new PrintWriter(new FileWriter(selectedFile));",
                    "        }",
                    "        catch (Exception e) {",
                    "            throw new IllegalArgumentException(\"Can't open file \\\"\" + selectedFile.getName() + \"\\\" for output.\\n\"",
                    "                             + \"(Error :\" + e + \")\");",
                    "        }",
                    "        if (!writingStandardOutput) {",
                    "            try {",
                    "                out.close();",
                    "            }",
                    "            catch (Exception e) {",
                    "            }",
                    "        }",
                    "        out = newout;",
                    "        writingStandardOutput = false;",
                    "        outputFileName = selectedFile.getName();",
                    "        outputErrorCount = 0;",
                    "        return true;",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * If TextIO is currently reading from a file, then the return value is the name of the file.  ",
                    "     * If the class is reading from standard input or from a stream, then the return value is null.",
                    "     */",
                    "    public static String getInputFileName() {",
                    "        return inputFileName;",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * If TextIO is currently writing to a file, then the return value is the name of the file.  ",
                    "     * If the class is writing to standard output or to a stream, then the return value is null.",
                    "     */",
                    "    public static String getOutputFileName() {",
                    "        return outputFileName;",
                    "    }",
                    "    ",
                    "",
                    "    // *************************** Output Methods *********************************",
                    "        ",
                    "    /**",
                    "     * Write a single value to the current output destination, using the default format",
                    "     * and no extra spaces.  This method will handle any type of parameter, even one",
                    "     * whose type is one of the primitive types.",
                    "     */",
                    "    public static void put(Object x) { ",
                    "        out.print(x); ",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Write a single value to the current output destination, using the default format",
                    "     * and outputting at least minChars characters (with extra spaces added before the",
                    "     * output value if necessary).  This method will handle any type of parameter, even one",
                    "     * whose type is one of the primitive types.",
                    "     * @param x The value to be output, which can be of any type.",
                    "     * @param minChars The minimum number of characters to use for the output.  If x requires fewer",
                    "     * then this number of characters, then extra spaces are added to the front of x to bring",
                    "     * the total up to minChars.  If minChars is less than or equal to zero, then x will be printed",
                    "     * in the minimum number of spaces possible.",
                    "     */",
                    "    public static void put(Object x, int minChars)  { ",
                    "        if (minChars <= 0)",
                    "            out.print(x);",
                    "        else",
                    "            out.printf(\"%\" + minChars + \"s\", x);",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "        ",
                    "    /**",
                    "     * This is equivalent to put(x), followed by an end-of-line.",
                    "     */",
                    "    public static void putln(Object x) { ",
                    "        out.println(x);",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    /**",
                    "     * This is equivalent to put(x,minChars), followed by an end-of-line.",
                    "     */",
                    "    public static void putln(Object x, int minChars) {",
                    "        put(x,minChars);",
                    "        out.println();",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "",
                    "    /**",
                    "     * Write an end-of-line character to the current output destination.",
                    "     */",
                    "    public static void putln() {",
                    "        out.println();",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Writes formatted output values to the current output destination.  This method has the",
                    "     * same function as System.out.printf(); the details of formatted output are not discussed",
                    "     * here.  The first parameter is a string that describes the format of the output.  There",
                    "     * can be any number of additional parameters; these specify the values to be output and",
                    "     * can be of any type.  This method will throw an IllegalArgumentException if the",
                    "     * format string is null or if the format string is illegal for the values that are being",
                    "     * output.",
                    "     */",
                    "    public static void putf(String format, Object... items) {",
                    "        if (format == null)",
                    "            throw new IllegalArgumentException(\"Null format string in TextIO.putf() method.\");",
                    "        try {",
                    "            out.printf(format,items);",
                    "        }",
                    "        catch (IllegalFormatException e) {",
                    "            throw new IllegalArgumentException(\"Illegal format string in TextIO.putf() method.\");",
                    "        }",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    // *************************** Input Methods *********************************",
                    "",
                    "    /**",
                    "     * Test whether the next character in the current input source is an end-of-line.  Note that",
                    "     * this method does NOT skip whitespace before testing for end-of-line -- if you want to do",
                    "     * that, call skipBlanks() first.",
                    "     */",
                    "    public static boolean eoln() { ",
                    "        return peek() == '\\n'; ",
                    "    }",
                    "",
                    "    /**",
                    "     * Test whether the next character in the current input source is an end-of-file.  Note that",
                    "     * this method does NOT skip whitespace before testing for end-of-line -- if you want to do",
                    "     * that, call skipBlanks() or skipWhitespace() first.",
                    "     */",
                    "    public static boolean eof()  { ",
                    "        return peek() == EOF; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Reads the next character from the current input source.  The character can be a whitespace",
                    "     * character; compare this to the getChar() method, which skips over whitespace and returns the",
                    "     * next non-whitespace character.  An end-of-line is always returned as the character '\\n', even",
                    "     * when the actual end-of-line in the input source is something else, such as '\\r' or \"\\r\\n\".",
                    "     * This method will throw an IllegalArgumentException if the input is at end-of-file (which will ",
                    "     * not ordinarily happen if reading from standard input).",
                    "     */",
                    "    public static char getAnyChar() { ",
                    "        return readChar(); ",
                    "    }",
                    "",
                    "    /**",
                    "     * Returns the next character in the current input source, without actually removing that",
                    "     * character from the input.  The character can be a whitespace character and can be the",
                    "     * end-of-file character (specified by the constant TextIO.EOF).An end-of-line is always returned ",
                    "     * as the character '\\n', even when the actual end-of-line in the input source is something else, ",
                    "     * such as '\\r' or \"\\r\\n\".  This method never causes an error.",
                    "     */",
                    "    public static char peek() { ",
                    "        return lookChar();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips over any whitespace characters, except for end-of-lines.  After this method is called,",
                    "     * the next input character is either an end-of-line, an end-of-file, or a non-whitespace character.",
                    "     * This method never causes an error.  (Ordinarily, end-of-file is not possible when reading from",
                    "     * standard input.)",
                    "     */",
                    "    public static void skipBlanks() { ",
                    "        char ch=lookChar();",
                    "        while (ch != EOF && ch != '\\n' && Character.isWhitespace(ch)) {",
                    "            readChar();",
                    "            ch = lookChar();",
                    "        }",
                    "    }",
                    "",
                    "    /**",
                    "     * Skips over any whitespace characters, including for end-of-lines.  After this method is called,",
                    "     * the next input character is either an end-of-file or a non-whitespace character.",
                    "     * This method never causes an error. (Ordinarily, end-of-file is not possible when reading from",
                    "     * standard input.)",
                    "     */",
                    "    private static void skipWhitespace() {",
                    "        char ch=lookChar();",
                    "        while (ch != EOF && Character.isWhitespace(ch)) {",
                    "            readChar();",
                    "            if (ch == '\\n' && readingStandardInput && writingStandardOutput) {",
                    "                out.print(\"? \");",
                    "                out.flush();",
                    "            }",
                    "            ch = lookChar();",
                    "        }",
                    "    }",
                    "",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type byte from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static byte getlnByte() { ",
                    "        byte x=getByte(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type short from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static short getlnShort() {",
                    "        short x=getShort();",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type int from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static int getlnInt() { ",
                    "        int x=getInt(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type long from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static long getlnLong() {",
                    "        long x=getLong(); ",
                    "        emptyBuffer(); ",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type float from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static float getlnFloat() {",
                    "        float x=getFloat(); ",
                    "        emptyBuffer(); ",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type double from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static double getlnDouble() { ",
                    "        double x=getDouble(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type char from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  Note that the value",
                    "     * that is returned will be a non-whitespace character; compare this with the getAnyChar() method.",
                    "     * When using standard IO, this will not produce an error.  In other cases, an error can occur if",
                    "     * an end-of-file is encountered.",
                    "     */",
                    "    public static char getlnChar() {",
                    "        char x=getChar(); ",
                    "        emptyBuffer(); ",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type boolean from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     * <p>Legal inputs for a boolean input are: true, t, yes, y, 1, false, f, no, n, and 0; letters can be",
                    "     * either upper case or lower case. One \"word\" of input is read, using the getWord() method, and it",
                    "     * must be one of these; note that the \"word\"  must be terminated by a whitespace character (or end-of-file).",
                    "     */",
                    "    public static boolean getlnBoolean() { ",
                    "        boolean x=getBoolean(); ",
                    "        emptyBuffer();",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads one \"word\" from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  A word is defined as",
                    "     * a sequence of non-whitespace characters (not just letters!).   When using standard IO,",
                    "     * this will not produce an error.  In other cases, an IllegalArgumentException will be thrown",
                    "     * if an end-of-file is encountered.",
                    "     */",
                    "    public static String getlnWord() {",
                    "        String x=getWord(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * This is identical to getln().",
                    "     */",
                    "    public static String getlnString() {",
                    "        return getln();",
                    "    } ",
                    "    ",
                    "    /**",
                    "     * Reads all the characters from the current input source, up to the next end-of-line.  The end-of-line",
                    "     * is read but is not included in the return value.  Any other whitespace characters on the line are retained,",
                    "     * even if they occur at the start of input.  The return value will be an empty string if there are",
                    "     * no characters before the end-of-line.  When using standard IO, this will not produce an error.  ",
                    "     * In other cases, an IllegalArgumentException will be thrown if an end-of-file is encountered.",
                    "     */",
                    "    public static String getln() {",
                    "        StringBuffer s = new StringBuffer(100);",
                    "        char ch = readChar();",
                    "        while (ch != '\\n') {",
                    "            s.append(ch);",
                    "            ch = readChar();",
                    "        }",
                    "        return s.toString();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type byte from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static byte getByte()   { ",
                    "        return (byte)readInteger(-128L,127L); ",
                    "    }",
                    "",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type short from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static short getShort() { ",
                    "        return (short)readInteger(-32768L,32767L);",
                    "    }   ",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type int from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static int getInt()     { ",
                    "        return (int)readInteger(Integer.MIN_VALUE, Integer.MAX_VALUE);",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type long from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static long getLong()   { ",
                    "        return readInteger(Long.MIN_VALUE, Long.MAX_VALUE); ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a single non-whitespace character from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error.  In other cases, an IllegalArgumentException will be thrown if an end-of-file",
                    "     * is encountered.",
                    "     */",
                    "    public static char getChar() { ",
                    "        skipWhitespace();",
                    "        return readChar();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type float from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static float getFloat() {",
                    "        float x = 0.0F;",
                    "        while (true) {",
                    "            String str = readRealString();",
                    "            if (str == null) {",
                    "                errorMessage(\"Floating point number not found.\",",
                    "                        \"Real number in the range \" + (-Float.MAX_VALUE) + \" to \" + Float.MAX_VALUE);",
                    "            }",
                    "            else {",
                    "                try { ",
                    "                    x = Float.parseFloat(str); ",
                    "                }",
                    "                catch (NumberFormatException e) {",
                    "                    errorMessage(\"Illegal floating point input, \" + str + \".\",",
                    "                            \"Real number in the range \" +  (-Float.MAX_VALUE) + \" to \" + Float.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                if (Float.isInfinite(x)) {",
                    "                    errorMessage(\"Floating point input outside of legal range, \" + str + \".\",",
                    "                            \"Real number in the range \" +  (-Float.MAX_VALUE) + \" to \" + Float.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                break;",
                    "            }",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type double from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static double getDouble() {",
                    "        double x = 0.0;",
                    "        while (true) {",
                    "            String str = readRealString();",
                    "            if (str == null) {",
                    "                errorMessage(\"Floating point number not found.\",",
                    "                        \"Real number in the range \" + (-Double.MAX_VALUE) + \" to \" + Double.MAX_VALUE);",
                    "            }",
                    "            else {",
                    "                try { ",
                    "                    x = Double.parseDouble(str); ",
                    "                }",
                    "                catch (NumberFormatException e) {",
                    "                    errorMessage(\"Illegal floating point input, \" + str + \".\",",
                    "                            \"Real number in the range \" + (-Double.MAX_VALUE) + \" to \" + Double.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                if (Double.isInfinite(x)) {",
                    "                    errorMessage(\"Floating point input outside of legal range, \" + str + \".\",",
                    "                            \"Real number in the range \" + (-Double.MAX_VALUE) + \" to \" + Double.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                break;",
                    "            }",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads one \"word\" from input. Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  A word is defined as",
                    "     * a sequence of non-whitespace characters (not just letters!).   When using standard IO,",
                    "     * this will not produce an error.  In other cases, an IllegalArgumentException will be thrown",
                    "     * if an end-of-file is encountered.",
                    "     */",
                    "    public static String getWord() {",
                    "        skipWhitespace();",
                    "        StringBuffer str = new StringBuffer(50);",
                    "        char ch = lookChar();",
                    "        while (ch == EOF || !Character.isWhitespace(ch)) {",
                    "            str.append(readChar());",
                    "            ch = lookChar();",
                    "        }",
                    "        return str.toString();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type boolean from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     * <p>Legal inputs for a boolean input are: true, t, yes, y, 1, false, f, no, n, and 0; letters can be",
                    "     * either upper case or lower case. One \"word\" of input is read, using the getWord() method, and it",
                    "     * must be one of these; note that the \"word\"  must be terminated by a whitespace character (or end-of-file).",
                    "     */",
                    "    public static boolean getBoolean() {",
                    "        boolean ans = false;",
                    "        while (true) {",
                    "            String s = getWord();",
                    "            if ( s.equalsIgnoreCase(\"true\") || s.equalsIgnoreCase(\"t\") ||",
                    "                    s.equalsIgnoreCase(\"yes\")  || s.equalsIgnoreCase(\"y\") ||",
                    "                    s.equals(\"1\") ) {",
                    "                ans = true;",
                    "                break;",
                    "            }",
                    "            else if ( s.equalsIgnoreCase(\"false\") || s.equalsIgnoreCase(\"f\") ||",
                    "                    s.equalsIgnoreCase(\"no\")  || s.equalsIgnoreCase(\"n\") ||",
                    "                    s.equals(\"0\") ) {",
                    "                ans = false;",
                    "                break;",
                    "            }",
                    "            else",
                    "                errorMessage(\"Illegal boolean input value.\",",
                    "                \"one of:  true, false, t, f, yes, no, y, n, 0, or 1\");",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return ans;",
                    "    }",
                    "    ",
                    "    // ***************** Everything beyond this point is private implementation detail *******************",
                    "    ",
                    "    private static String inputFileName;  // Name of file that is the current input source, or null if the source is not a file.",
                    "    private static String outputFileName; // Name of file that is the current output destination, or null if the destination is not a file.",
                    "    ",
                    "    private static JFileChooser fileDialog; // Dialog used by readUserSelectedFile() and writeUserSelectedFile()",
                    "    ",
                    "    private final static BufferedReader standardInput = new BufferedReader(new InputStreamReader(System.in));  // wraps standard input stream",
                    "    private final static PrintWriter standardOutput = new PrintWriter(System.out);  // wraps standard output stream",
                    "",
                    "    private static BufferedReader in = standardInput;  // Stream that data is read from; the current input source.",
                    "    private static PrintWriter out = standardOutput;   // Stream that data is written to; the current output destination.",
                    "    ",
                    "    private static boolean readingStandardInput = true;",
                    "    private static boolean writingStandardOutput = true;",
                    "    ",
                    "    private static int inputErrorCount;  // Number of consecutive errors on standard input; reset to 0 when a successful read occurs.",
                    "    private static int outputErrorCount;  // Number of errors on standard output since it was selected as the output destination.",
                    "    ",
                    "    private static Matcher integerMatcher;  // Used for reading integer numbers; created from the integer Regex Pattern.",
                    "    private static Matcher floatMatcher;   // Used for reading floating point numbers; created from the floatRegex Pattern.",
                    "    private final static Pattern integerRegex = Pattern.compile(\"(\\\\+|-)?[0-9]+\");",
                    "    private final static Pattern floatRegex = Pattern.compile(\"(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))((e|E)(\\\\+|-)?[0-9]+)?\");",
                    "    ",
                    "    private static String buffer = null;  // One line read from input.",
                    "    private static int pos = 0;           // Position of next char in input line that has not yet been processed.",
                    "    ",
                    "    private static String readRealString() {   // read chars from input following syntax of real numbers",
                    "        skipWhitespace();",
                    "        if (lookChar() == EOF)",
                    "            return null;",
                    "        if (floatMatcher == null)",
                    "            floatMatcher = floatRegex.matcher(buffer);",
                    "        floatMatcher.region(pos,buffer.length());",
                    "        if (floatMatcher.lookingAt()) {",
                    "            String str = floatMatcher.group();",
                    "            pos = floatMatcher.end();",
                    "            return str;",
                    "        }",
                    "        else ",
                    "            return null;",
                    "    }",
                    "    ",
                    "    private static String readIntegerString() {  // read chars from input following syntax of integers",
                    "        skipWhitespace();",
                    "        if (lookChar() == EOF)",
                    "            return null;",
                    "        if (integerMatcher == null)",
                    "            integerMatcher = integerRegex.matcher(buffer);",
                    "        integerMatcher.region(pos,buffer.length());",
                    "        if (integerMatcher.lookingAt()) {",
                    "            String str = integerMatcher.group();",
                    "            pos = integerMatcher.end();",
                    "            return str;",
                    "        }",
                    "        else ",
                    "            return null;",
                    "    }",
                    "    ",
                    "    private static long readInteger(long min, long max) {  // read long integer, limited to specified range",
                    "        long x=0;",
                    "        while (true) {",
                    "            String s = readIntegerString();",
                    "            if (s == null){",
                    "                errorMessage(\"Integer value not found in input.\",",
                    "                        \"Integer in the range \" + min + \" to \" + max);",
                    "            }",
                    "            else {",
                    "                String str = s.toString();",
                    "                try { ",
                    "                    x = Long.parseLong(str);",
                    "                }",
                    "                catch (NumberFormatException e) {",
                    "                    errorMessage(\"Illegal integer input, \" + str + \".\",",
                    "                            \"Integer in the range \" + min + \" to \" + max);",
                    "                    continue;",
                    "                }",
                    "                if (x < min || x > max) {",
                    "                    errorMessage(\"Integer input outside of legal range, \" + str + \".\",",
                    "                            \"Integer in the range \" + min + \" to \" + max);",
                    "                    continue;",
                    "                }",
                    "                break;",
                    "            }",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return x;",
                    "    }",
                    "    ",
                    "    ",
                    "    private static void errorMessage(String message, String expecting) {  // Report error on input.",
                    "        if (readingStandardInput && writingStandardOutput) {",
                    "                // inform user of error and force user to re-enter.",
                    "            out.println();",
                    "            out.print(\"  *** Error in input: \" + message + \"\\n\");",
                    "            out.print(\"  *** Expecting: \" + expecting + \"\\n\");",
                    "            out.print(\"  *** Discarding Input: \");",
                    "            if (lookChar() == '\\n')",
                    "                out.print(\"(end-of-line)\\n\\n\");",
                    "            else {",
                    "                while (lookChar() != '\\n')    // Discard and echo remaining chars on the current line of input.",
                    "                    out.print(readChar());",
                    "                out.print(\"\\n\\n\");",
                    "            }",
                    "            out.print(\"Please re-enter: \");",
                    "            out.flush();",
                    "            readChar();  // discard the end-of-line character",
                    "            inputErrorCount++;",
                    "            if (inputErrorCount >= 10)",
                    "                throw new IllegalArgumentException(\"Too many input consecutive input errors on standard input.\");",
                    "        }",
                    "        else if (inputFileName != null)",
                    "            throw new IllegalArgumentException(\"Error while reading from file \\\"\" + inputFileName + \"\\\":\\n\" ",
                    "                    + message + \"\\nExpecting \" + expecting);",
                    "        else",
                    "            throw new IllegalArgumentException(\"Error while reading from inptu stream:\\n\" ",
                    "                    + message + \"\\nExpecting \" + expecting);",
                    "    }",
                    "    ",
                    "    private static char lookChar() {  // return next character from input",
                    "        if (buffer == null || pos > buffer.length())",
                    "            fillBuffer();",
                    "        if (buffer == null)",
                    "            return EOF;",
                    "        else if (pos == buffer.length())",
                    "            return '\\n';",
                    "        else ",
                    "            return buffer.charAt(pos);",
                    "    }",
                    "    ",
                    "    private static char readChar() {  // return and discard next character from input",
                    "        char ch = lookChar();",
                    "        if (buffer == null) {",
                    "            if (readingStandardInput)",
                    "                throw new IllegalArgumentException(\"Attempt to read past end-of-file in standard input???\");",
                    "            else",
                    "                throw new IllegalArgumentException(\"Attempt to read past end-of-file in file \\\"\" + inputFileName + \"\\\".\");",
                    "        }",
                    "        pos++;",
                    "        return ch;",
                    "    }",
                    "        ",
                    "    private static void fillBuffer() {    // Wait for user to type a line and press return,",
                    "        try {",
                    "            buffer = in.readLine();",
                    "        }",
                    "        catch (Exception e) {",
                    "            if (readingStandardInput)",
                    "                throw new IllegalArgumentException(\"Error while reading standard input???\");",
                    "            else if (inputFileName != null)",
                    "                throw new IllegalArgumentException(\"Error while attempting to read from file \\\"\" + inputFileName + \"\\\".\");",
                    "            else",
                    "                throw new IllegalArgumentException(\"Errow while attempting to read form an input stream.\");",
                    "        }",
                    "        pos = 0;",
                    "        floatMatcher = null;",
                    "        integerMatcher = null;",
                    "    }",
                    "    ",
                    "    private static void emptyBuffer() {   // discard the rest of the current line of input",
                    "        buffer = null;",
                    "    }",
                    "    ",
                    "    private static void outputError(String message) {  // Report an error on output.",
                    "        if (writingStandardOutput) {",
                    "            System.err.println(\"Error occurred in TextIO while writing to standard output!!\");",
                    "            outputErrorCount++;",
                    "            if (outputErrorCount >= 10) {",
                    "                outputErrorCount = 0;",
                    "                throw new IllegalArgumentException(\"Too many errors while writing to standard output.\");",
                    "            }",
                    "        }",
                    "        else if (outputFileName != null){",
                    "            throw new IllegalArgumentException(\"Error occurred while writing to file \\\"\" ",
                    "                    + outputFileName+ \"\\\":\\n   \" + message);",
                    "        }",
                    "        else {",
                    "            throw new IllegalArgumentException(\"Error occurred while writing to output stream:\\n   \" + message);",
                    "        }",
                    "    }",
                    "        ",
                    "} // end of class TextIO"
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr020c66ab.TextIO",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 586
            },
            "evaluatorReader": true,
            "lineCount": 1008,
            "initialization": true
        },
        {
            "id": "sectionkeHbFD",
            "type": "section",
            "title": "NetIDPair",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "NetIDPair",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.Arrays;",
                    "",
                    "/**",
                    " *  A simple pair POD that assigns a random number to a NetID",
                    " *  and stores the two.",
                    " *  @author CS125 Research",
                    " */",
                    "public class NetIDPair {",
                    "\tprivate String netID;",
                    "\tprivate int random;",
                    "\t",
                    "\t/**",
                    "\t * Struct constructor.",
                    "\t * ",
                    "\t * @param newNetid   NetID of student.",
                    "\t * @param newRandom  Random code associated with this NetID.",
                    "\t */",
                    "\tpublic NetIDPair(String newNetID, int newRandom){",
                    "\t\tnetID = newNetID;",
                    "\t\trandom = newRandom;\t",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The code associated with this netID.",
                    "\t */\t",
                    "\tpublic int getRandom() { return random; }",
                    "\t",
                    "\t/**",
                    "\t * @return The string representation of this pair. Just a comma",
                    " \t *         separated juxtaposition of netID and code.",
                    "\t */",
                    "\tpublic String toString(){",
                    "\t\tchar[] build = new char[netID.length()];",
                    "\t\tArrays.fill(build, '*');",
                    "\t\tbuild[0] = netID.charAt(0);",
                    "\t\tint last = netID.length()-1;",
                    "\t\tbuild[last] = netID.charAt(last);",
                    "\t\treturn (new String(build)) + \": \" + random;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return True iff searchID matches this NetIDPair's netID.",
                    "\t */",
                    "\tpublic boolean equals(String searchID){",
                    "\t\treturn this.netID.equals(searchID);",
                    "\t}",
                    "\t",
                    "}",
                    ""
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr020c66ab.NetIDPair",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 577
            },
            "evaluatorReader": true,
            "lineCount": 49,
            "initialization": true
        },
        {
            "id": "sectionsR1i5J",
            "type": "section",
            "title": "NRList",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "NRList",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.ArrayList;",
                    "import java.util.Iterator;",
                    "/**",
                    " *  A simple map-like list of NetIDPairs with a file argument constructor.",
                    " *  Can return the code associated with a particular netID passed into its",
                    " *  getSecret() method.",
                    " *  @author CS125 Research",
                    " */",
                    "public class NRList implements Iterable<NetIDPair>{",
                    "\t",
                    "\t/** A list of all NetIDPairs extracted from the roster */",
                    "\tArrayList <NetIDPair> pairList = new ArrayList<NetIDPair>();",
                    "\t",
                    "\t/**",
                    "\t * File argument constructor. Reads input file and fills up data",
                    "\t * structure with NetIDPair objects from the file.",
                    "\t *",
                    "\t * @param inFile  The name of the file from which we read netIDs.",
                    "\t * @param outFile Debug output file.",
                    "\t * @param range   Range element for NetIDPair random generator.",
                    "\t */",
                    "\tpublic NRList(String inFile, String outFile, int range){",
                    "\t\tfillList(inFile, outFile, range);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Helper function for constructor that does all the work.",
                    "\t * Takes in filenames to get a source of NetIDs and a",
                    "\t * range to determine the range of ID codes assigned. Also used",
                    "\t * to add new NetIDPairs to an existing NRList.",
                    "\t * ",
                    "\t * @param readFilePath The source file for all NetIDs.",
                    "\t * @param range        Upper bound on ID code assigned.",
                    "\t */",
                    "\tpublic void fillList(String readFilePath, String writeFilePath, int range)",
                    "\t{",
                    "\t\tTextIO.readFile(readFilePath);",
                    "\t\t",
                    "\t\tif (writeFilePath != null)",
                    "\t\t\tTextIO.writeFile(writeFilePath);",
                    "\t\t",
                    "\t\twhile(!TextIO.eof())",
                    "\t\t{",
                    "\t\t\tString line = TextIO.getln();",
                    "\t\t\tString netID = line.split(\",\")[1];",
                    "\t\t\tNetIDPair potentialPair;",
                    "\t\t\t",
                    "\t\t\tdo{",
                    "\t\t\t\tint randomID = (int)(Math.random()*range);",
                    "\t\t\t\tpotentialPair = new NetIDPair(netID,randomID);",
                    "\t\t\t} while(check(potentialPair));",
                    "\t",
                    "\t\t\tpairList.add(potentialPair);",
                    "\t\t}",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t *  Private helper function that searches the NRList to ensure that",
                    "\t *  no two NetIDPair instances therein correspond to the same code.",
                    "\t *",
                    "\t *  @param potentialPair  A potential NetIDPair that may be added to the list.",
                    "\t *  @return True if the code of potentialPair isn't already found in",
                    "\t *          the NRList.",
                    "\t */",
                    "\tprivate boolean check(NetIDPair potentialPair){",
                    "\t\tboolean duplicate = false;",
                    "\t\tfor(int x = 0; x < pairList.size(); x++){",
                    "\t\t\tduplicate = pairList.get(x).getRandom()==potentialPair.getRandom();\t",
                    "\t\t\tif(duplicate) break;",
                    "\t\t}",
                    "\t\treturn duplicate;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t *  Returns the code corresponding to a given netID.",
                    "\t *  ",
                    "\t *  @param netID  The netID whose code is being searched.",
                    "\t * ",
                    "\t *  @return  The code of the netID argument if it is found or -1 otherwise.",
                    "\t */",
                    "\tpublic int getSecret(String netID)",
                    "\t{",
                    "\t\tfor(NetIDPair elem : pairList)",
                    "\t\t\tif (elem.equals(netID))",
                    "\t\t\t\treturn elem.getRandom();",
                    "\t\treturn -1;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Prints out the contents of this NRList separated by",
                    "\t * newlines.",
                    "\t */",
                    "\tpublic void printList() {",
                    "\t\tfor (int i = 0; i < pairList.size(); i++) {",
                    "\t\t\tSystem.out.println(pairList.get(i));",
                    "\t\t}",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return an iterator to the start of this NRList.",
                    "\t */",
                    "\tpublic NRIterator iterator() { return new NRIterator(); }",
                    "\t",
                    "\t/**",
                    "\t * Iterator class for NRList. Allows sequential access of all",
                    "\t * elements in this container.",
                    "\t */",
                    "\tpublic class NRIterator implements Iterator<NetIDPair>{",
                    "\t\tprivate int curr;",
                    "\t\t",
                    "\t\tpublic NRIterator()      { curr = 0; }",
                    "\t\tpublic boolean hasNext() { return curr < pairList.size(); }",
                    "\t\tpublic NetIDPair next()  { return pairList.get(curr++); }",
                    "\t\tpublic void remove()     { throw new UnsupportedOperationException(); }",
                    "\t}",
                    "}",
                    ""
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr020c66ab.NRList",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 574
            },
            "evaluatorReader": true,
            "lineCount": 117,
            "initialization": true
        },
        {
            "id": "sectionBARdMF",
            "type": "section",
            "title": "FeebackEntry",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "FeedbackEntry",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.*;",
                    "import java.text.SimpleDateFormat;",
                    "/**",
                    " *  This class is a simple data structure that represents an entry from the CS125",
                    " *  lecture feedback app. It contains a pair of encoded NetIDs, a grade, two",
                    " *  feedback strings, and a date string.",
                    " *  @author CS125 Research",
                    " */",
                    "",
                    "public final class FeedbackEntry{",
                    "\t",
                    "\tprivate boolean good = false;",
                    "\tprivate int grade = -1;",
                    "\tprivate int personID = -1;",
                    "\tprivate int partnerID = -1;",
                    "\tprivate String strengths;",
                    "\tprivate String weaknesses;",
                    "\tprivate Date date;",
                    "\t",
                    "\t/**",
                    "\t * String constructor. Takes an unprocessed line from a CSV file and",
                    "\t * parses it as a valid FeedbackEntry using a passed-in NRList to",
                    "\t * verify NetIDs. The constructor exits early and marks the entry as",
                    "\t * bad if any NetIDs are missing or do not belong to any students in",
                    "\t * the NRList. [It also throws an exception if the data clearly",
                    "\t * cannot represent an entry made by a student. Useful for debugging.]",
                    "\t *",
                    "\t *  @param data  An unprocessed line to parse. Must be formatted in the",
                    "\t *               form \"netid1\", \"netid2\", \"5\", \"Strengths\", ",
                    "\t *               \"Weaknesses\", \"Date\";",
                    "\t *  @param map   A list of all netIDs of students in the class",
                    "\t *               and their corresponding codes.",
                    "\t */",
                    "\tpublic FeedbackEntry(String data, NRList map){",
                    "\t\tgood = true;",
                    "\t\tcheckCorruptData(data);",
                    "\t\tString[] separated = splitCommas(data);",
                    "\t\tfor (int i = 0; i < separated.length; ++i)",
                    "\t\t\tseparated[i] = process(separated[i]);",
                    "\t\tpersonID = map.getSecret(separated[0]);",
                    "\t\tpartnerID = map.getSecret(separated[1]);",
                    "\t\tgrade = Integer.parseInt(separated[2]);",
                    "\t\tif (personID == -1 || partnerID == -1 || grade > 10 || grade < 1 || ",
                    "\t\t    personID == partnerID){",
                    "\t\t\tgood = false;",
                    "\t\t}",
                    "\t\tstrengths = separated[3];",
                    "\t\tweaknesses = separated[4];",
                    "\t\ttry{",
                    "\t\t\tdate = new ",
                    "\t\t\t    SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\").parse(separated[5]);",
                    "\t\t}catch(Exception e){}",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * This merge constructor creates a FeedbackEntry whose parameters are",
                    "\t * all the same as those of the last element in the argument, except",
                    "\t * for the written feedback parameters. These parameters are formed",
                    "\t * from a processed concatenation of all elements in the argument.",
                    "\t * ",
                    "\t * @param duplicates An array of FeedbackEntries corresponding to the",
                    "\t *                   same lecture and having the same personID.",
                    "\t */",
                    "\tpublic FeedbackEntry(FeedbackEntry[] duplicates){",
                    "\t\tint last = duplicates.length - 1;",
                    "\t\tpersonID = duplicates[last].personID;",
                    "\t\tpartnerID = duplicates[last].partnerID;",
                    "\t\tgrade = duplicates[last].grade;",
                    "\t\tgood = duplicates[last].good;",
                    "\t\tif (duplicates.length == 1){",
                    "\t\t\tstrengths = duplicates[0].strengths;",
                    "\t\t\tweaknesses = duplicates[0].weaknesses;",
                    "\t\t\treturn;",
                    "\t\t}",
                    "\t\tStringBuilder strBuild = new StringBuilder();",
                    "\t\tStringBuilder weakBuild = new StringBuilder();",
                    "\t\tfor (FeedbackEntry elem : duplicates){",
                    "\t\t\tstrBuild.append('{' + elem.strengths + '}');",
                    "\t\t\tweakBuild.append('{' + elem.weaknesses + '}');",
                    "\t\t}",
                    "\t\tstrengths = strBuild.toString();",
                    "\t\tweaknesses = weakBuild.toString();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Returns true if this entry is valid. This implies that both NetID ",
                    "\t * codes were entered and actually represent real students and that the ",
                    "\t * grade was between 1 and 10 and that the date was a valid date.",
                    "\t *",
                    "\t *  @return True for valid entries, false for invalid entries.",
                    "\t */",
                    "\tpublic boolean valid()        {return good;}",
                    "",
                    "\t/**",
                    "\t *  @return How well the student rated this lecture, from 1 to 10.",
                    "\t */",
                    "\tpublic int     getGrade()     {return grade;}",
                    "",
                    "\t/**",
                    "\t *  @return The int code representing the netID of the first person.",
                    "\t */",
                    "\tpublic int     getPersonID()  {return personID;}",
                    "",
                    "\t/**",
                    "\t *  @return The int code representing the netID of the second person.",
                    "\t */",
                    "\tpublic int     getPartnerID() {return partnerID;}",
                    "",
                    "\t/**",
                    "\t *  @return The student's report on what he/she understood from lecture.",
                    "\t */",
                    "\tpublic String  getStrength()  { return strengths; }",
                    "",
                    "\t/**",
                    "\t *  @return The student's report on what he/she did not understand from ",
                    "\t *          lecture.",
                    "\t */",
                    "\tpublic String  getWeakness()  { return weaknesses; }",
                    "",
                    "\t/**",
                    "\t *  @return A copy of the date of this entry.",
                    "\t */",
                    "\tpublic Date    getDate()      { return new Date(date.getTime()); }",
                    "",
                    "\t/**",
                    "\t *  Method that indicates whether this entry has any written",
                    "\t *  feedback information at all.",
                    "\t *",
                    "\t *  @return True if either weaknesses or strengths is nonempty, false",
                    "\t *          otherwise.",
                    "\t */",
                    "\tpublic boolean hasFeedback(){",
                    "\t\treturn (strengths.length() > 0 || weaknesses.length() > 0);",
                    "\t}",
                    "",
                    "\t/**",
                    "\t *  Returns a simple but complete representation of this entry. Note",
                    "\t *  that invalid entries return \"INVALID ENTRY\". Not for file writing.",
                    "\t *",
                    "\t *  @return \"INVALID_ENTRY\" for invalid entries or a single-line ",
                    "\t * \t\t\trepresentation of all data members of this entry.",
                    "\t */",
                    "\tpublic String toString(){",
                    "\t\tString result = String.format(\"Student: %d Partner: %d Grade: %d\"",
                    "\t\t                  + \"Good: \\\"%s\\\" Bad: \\\"%s\\\" Date: %s\", ",
                    "\t\t                     personID, partnerID, grade,",
                    "\t\t                     strengths, weaknesses, date);",
                    "\t\treturn (!good ? \"INVALID ENTRY: \":\"\") + result;",
                    "\t}",
                    "\t\t",
                    "\t/**",
                    "\t *  Checks to see that a line passed into the constructor could possibly",
                    "\t *  represent an entry (valid or otherwise) made by a student and stored",
                    "\t *  in a CVS file. The method throws an IllegalArgumentException if the",
                    "\t *  line is invalid, namely if it doesn't have the right number of",
                    "\t *  elements or its elements are not surrounded with quotation marks.",
                    "\t *",
                    "\t *  @param line The line to be validated. ",
                    "\t */",
                    "\tprivate void checkCorruptData(String line){",
                    "\t\tSimpleDateFormat tst = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");",
                    "\t\ttry{",
                    "\t\t\tString[] separated = splitCommas(line);",
                    "\t\t\tDate tmp1 = tst.parse(separated[5]);",
                    "\t\t\tint tmp2 = Integer.parseInt(separated[2]);",
                    "\t\t}catch(Exception e){",
                    "\t\t\tthrow new IllegalArgumentException(line);",
                    "\t\t}",
                    "\t}",
                    "",
                    "\t/**",
                    "\t * Method that processes written feedback for better representation. ",
                    "\t * For example, should remove newlines and leading whitespaces.",
                    "\t *",
                    "\t * @param An unprocessed string of written feedback.",
                    "\t * @return A processed string of written feedback.",
                    "\t */",
                    "\tprivate String process(String unprocessed){",
                    "\t\tif (unprocessed.length() == 0)",
                    "\t\t\treturn unprocessed;",
                    "\t\tunprocessed = unprocessed.replace(\"\\n\", \" \"); //Removes newlines",
                    "\t\treturn unprocessed.trim();     //Removes trailing/leading whitespace",
                    "\t}",
                    "",
                    "",
                    "\t /**",
                    "\t  * Private helper method for constructor. Splits a String into a ",
                    "\t  * String[], splitting at (and getting rid of) commas ONLY IF those ",
                    "\t  * commas are not enclosed by quotes. Also converts double-double ",
                    "\t  * quotes into ordinary double quotes and implicitly throws an ",
                    "\t  * exception if the number of partitions is not exactly 6.",
                    "\t  *",
                    "\t  *  @params input The string to be parsed from a CVS file.",
                    "\t  *",
                    "\t  *  @return A String array containing the formatted contents of input, ",
                    "\t  *          split at commas iff they are enclosed by quotation marks.",
                    "\t  */",
                    "\tprivate static String[] splitCommas(String input)",
                    "\t{",
                    "\t    String[] partitions = new String[6];",
                    "\t    int partition = 0;",
                    "\t    StringBuilder build = new StringBuilder();",
                    "\t    boolean evenQuotes = true;",
                    "\t    boolean lastQuote = false;",
                    "\t    int i = 0;",
                    "\t    char current = '\\0';",
                    "\t    while (i < input.length()){",
                    "\t        while(i < input.length() && ",
                    "\t              (current = input.charAt(i++)) != ',' || !evenQuotes){",
                    "\t            if (current == '\\\"'){",
                    "\t                evenQuotes = !evenQuotes;",
                    "\t                if (lastQuote && !evenQuotes){",
                    "\t                    build.append(current);",
                    "\t                    lastQuote = false;",
                    "\t                    continue;",
                    "\t                }else",
                    "\t                    lastQuote = true;",
                    "\t            }else if (!evenQuotes){",
                    "\t                build.append(current);",
                    "\t                lastQuote = false;",
                    "\t            }",
                    "\t        }",
                    "\t        if (i == input.length() && input.charAt(i-1) != ',')",
                    "\t        \tbreak;",
                    "\t        partitions[partition++] = build.toString();",
                    "\t        build.setLength(0);",
                    "\t        lastQuote = false;",
                    "\t    }",
                    "\t    partitions[partition++] = build.toString();",
                    "\t    if (partition != 6)",
                    "\t    \tthrow new IllegalArgumentException();",
                    "\t    return partitions;",
                    "\t}",
                    "\t",
                    "\tpublic static void main(String[] args){",
                    "\t\t",
                    "\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr020c66ab.FeedbackEntry",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 575
            },
            "evaluatorReader": true,
            "lineCount": 238,
            "initialization": true
        },
        {
            "id": "Lecture",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    ""
                ]
            },
            "output": {
                "state": {},
                "selectedType": "Hidden",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 572
            },
            "evaluatorReader": true,
            "initialization": true,
            "tags": ""
        },
        {
            "id": "sectionSyKOjJ",
            "type": "section",
            "title": "CleanFeedbackData",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "CleanFeedbackData",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.*;",
                    "public class CleanFeedbackData {",
                    "",
                    "\t///TODO - document each of these array lists",
                    "\tpublic static ArrayList<FeedbackEntry> our_data;",
                    "\tpublic static ArrayList<FeedbackEntry> clean_data;",
                    "",
                    "\tpublic static void initialize() ",
                    "\t{",
                    "\t\tSystem.out.println(\"Calling CleanFeedbackData.initialize()\");",
                    "\t\t",
                    "\t\tNRList awesomeList= new NRList(\"/Users/chapman/Documents/workspaceResearch/EncodeNetID/src/roster.txt\",null,9000);",
                    "\t\tTextIO.readFile(\"/Users/chapman/Documents/workspaceResearch/secretText.txt\");",
                    "\t\t",
                    "\t\tour_data = new ArrayList<FeedbackEntry>();",
                    "\t\tclean_data = new ArrayList<FeedbackEntry>();",
                    "\t\t",
                    "\t\tTextIO.readFile(\"/Users/chapman/Documents/workspaceResearch/CleanFeedBackData/src/peerInteractions.fa2015.final.csv\");",
                    "\t\twhile (!TextIO.eof())",
                    "\t\t\tour_data.add(new FeedbackEntry(TextIO.getln(),awesomeList));",
                    "\t\tdouble num_valid = 0.0;",
                    "\t\tdouble count = 0.0;",
                    "",
                    "\t\tfor (FeedbackEntry elem : our_data){",
                    "\t\t\t++count;",
                    "\t\t\tif (elem.valid()){",
                    "\t\t\t\t++num_valid;",
                    "\t\t\t\tclean_data.add(elem);",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\tSystem.out.printf(\"Percentage of entries valid: %f%%\\nNumber of valid entries: %d\\nNumber of entries: %d\\n\", 100*num_valid/count, (int) num_valid, (int) count);",
                    "\t\tSystem.out.println(\"======================================================================================\\n\");",
                    "\t}",
                    "}",
                    "",
                    "",
                    ""
                ]
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr020c66ab.CleanFeedbackData",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 576
            },
            "evaluatorReader": true,
            "lineCount": 37,
            "initialization": true
        },
        {
            "id": "sectionp0HRAt",
            "type": "section",
            "title": "Lecture",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "Lectures",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.*;",
                    "",
                    "/**",
                    " * A model for a lecture object with a unique id corresponding to the lecture number, all the associated feedback entries, the date, and the lecture topics.",
                    " * @author CS125Research",
                    " */",
                    "public class Lecture implements Iterable<FeedbackEntry>{",
                    "",
                    "\tprivate static int AUTO_INCREMENT = 0;",
                    "\tprivate int lectureNumber; //TODO: Discuss this name",
                    "\tpublic ArrayList<FeedbackEntry> recordsByTime;",
                    "\tprivate Date date;",
                    "\tprivate String[] topics;// OR ArrayList<String>",
                    "\t",
                    "\t/**",
                    "\t * Base constructor called by all other constructors.",
                    "\t * Assigns a Date to this Lecture object.",
                    "\t * ",
                    "\t * @param d The time this lecture began.",
                    "\t */",
                    "\tpublic Lecture(Date d){",
                    "\t\tlectureNumber = AUTO_INCREMENT++;",
                    "\t\trecordsByTime = new ArrayList<FeedbackEntry>();",
                    "\t\tdate = new Date(d.getTime());",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Constructor with argument to assign the topics for",
                    "\t * the Lecture object.",
                    "\t * ",
                    "\t * @param d     The time this lecture began.",
                    "\t * @param topic A list of topics discussed during this lecture.",
                    "\t */",
                    "\tpublic Lecture(Date d, String[] topics){",
                    "\t\tthis(d);",
                    "\t\tthis.topics = topics.clone();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Constructor with argument to assign the topics for",
                    "\t * the Lecture object.",
                    "\t * ",
                    "\t * @param d     The time this lecture began.",
                    "\t * @param entry A Feedback entry that was submitted for this Lecture",
                    "\t */",
                    "\tpublic Lecture(Date d, FeedbackEntry entry){",
                    "\t\tthis(d);",
                    "\t\tthis.add(entry);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return A copy of this Lecture's date.",
                    "\t */",
                    "\tpublic Date getDate(){",
                    "\t\treturn new Date(date.getTime());",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * This method adds a FeedbackEntry to this Lecture. As a ",
                    "\t * precondition, entries should be added in chronological ",
                    "\t * order.",
                    "\t * ",
                    "\t * @param entry The entry to add to this Lecture. This entry should",
                    "\t *              come after the last entry added to the Lecture.",
                    "\t */",
                    "\tpublic void add(FeedbackEntry entry){",
                    "\t\trecordsByTime.add(entry);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Get the distribution of feedback number of entries that had a certain rating",
                    "\t * ",
                    "\t * @return A array where the first element would be the number of Feedback Entries that gave the Lecture a rating of 0, 2nd element -> rating of 1 and so on...",
                    "\t * ",
                    "\t * @param entry The entry to add to this Lecture. This entry should",
                    "\t *              come after the last entry added to the Lecture.",
                    "\t */",
                    "\tpublic int[] getValues() {",
                    "\t\tint[] values = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};",
                    "\t\tfor (FeedbackEntry element : recordsByTime)",
                    "\t\t\tvalues[element.getGrade() - 1]++;",
                    "\t\treturn values;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Static method that uses a right-biased binary search of existing Lectures",
                    "\t * to associate a FeedbackEntry with a Lecture. Runs in logarithmic time with",
                    "\t * respect to the number of Lectures.",
                    "\t *",
                    "\t * @param key The entry to be associated with a Lecture.",
                    "\t *",
                    "\t * @return The Lecture corresponding to an entry.",
                    "\t */",
                    "// \tpublic static Lecture get(FeedbackEntry key){",
                    "// \t\tArrayList<Lecture> lecs = LectureInitializer.lectures;",
                    "// \t\tint lo = 0;",
                    "// \t\tint hi = lecs.size()-1;",
                    "// \t\tDate search = key.getDate();",
                    "// \t\twhile (hi != lo){",
                    "// \t\t\tint mid = (lo + hi + 1)/2;",
                    "// \t\t\tDate comp = lecs.get(mid).getDate();",
                    "// \t\t\tswitch (search.compareTo(comp)){",
                    "// \t\t\tcase -1:",
                    "// \t\t\t\thi = mid-1; break; //Can exclude Dates that come after target",
                    "// \t\t\tcase 1:",
                    "// \t\t\t\tlo = mid; break;  //Can't exclude Dates that come before",
                    "// \t\t\tdefault:",
                    "// \t\t\t\treturn lecs.get(mid); //Unlikely case of exact match",
                    "// \t\t\t}",
                    "// \t\t}",
                    "// \t\treturn lecs.get(lo);",
                    "// \t}",
                    "\t",
                    "\t/**",
                    "\t * Method that returns the unadjusted rating distribution of all",
                    "\t * FeedbackEntries for this Lecture. The 0th element of this",
                    "\t * array corresponds to the number of entries with ratings of",
                    "\t * 1, and the 9th to the number of entries with ratings of 10.",
                    "\t * ",
                    "\t * @return An array of ints in which arr[idx] represents the number",
                    "\t *         of FeedbackEntries with ratings of (idx+1) in this Lecture",
                    "\t */",
                    "\tpublic int[] ratingDistribution() {",
                    "\t\tint[] values = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};",
                    "\t\tfor (FeedbackEntry element : recordsByTime)",
                    "\t\t\tvalues[element.getGrade() - 1]++;",
                    "\t\treturn values;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Calculates and returns the unadjusted average rating given by",
                    "\t * all FeedbackEntries for this lecture.",
                    "\t * ",
                    "\t * @return The average rating of all FeedbackEntries in this Lecture",
                    "\t */",
                    "\tpublic double ratingMean(){",
                    "\t\tif (recordsByTime.isEmpty())",
                    "\t\t\treturn -1;",
                    "\t\tdouble sum = 0;",
                    "\t\tfor (FeedbackEntry element : recordsByTime)",
                    "\t\t\tsum += element.getGrade();",
                    "\t\treturn sum/recordsByTime.size();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Calculates and returns the unadjusted standard deviation of ratings",
                    "\t * given by all FeedbackEntries for this lecture.",
                    "\t * ",
                    "\t * @return The rating standard deviation of all FeedbackEntries in this ",
                    "\t *         Lecture",
                    "\t */",
                    "\tpublic double ratingStdDev(){",
                    "\t\tif (recordsByTime.isEmpty())",
                    "\t\t\treturn -1;",
                    "\t\tdouble devSq = 0;",
                    "\t\tdouble mean = ratingMean();",
                    "\t\tfor (FeedbackEntry element : recordsByTime)",
                    "\t\t\tdevSq += Math.pow(element.getGrade()-mean,2);",
                    "\t\treturn Math.sqrt(devSq/recordsByTime.size());",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The number of FeedbackEntries in this Lecture.",
                    "\t */",
                    "\tpublic int entryCount(){",
                    "\t\treturn recordsByTime.size();",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return A string in the form \"ID: %, Date: %, Number of Entries: %,\"",
                    "\t *         \"Mean: %, Standard Deviation: %\"",
                    "\t */",
                    "\tpublic String toString(){",
                    "\t\treturn String.format(\"ID: %d\\n\\tDate: \", lectureNumber) + date",
                    "\t\t+ String.format(\"\\n\\tNumber of Entries: %d\\n\\t\"",
                    "\t\t    + \"Mean: %f\\n\\tStandard Deviation: %f\",",
                    "\t\t    recordsByTime.size(), ratingMean(), ratingStdDev());\t",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return A chronological iterator through all FeedbackEntries in",
                    "\t *         this Lecture.",
                    "\t */",
                    "\tpublic FeedbackIterator iterator() { return new FeedbackIterator(); }",
                    "\t",
                    "\t/**",
                    "\t * Iterator that goes through FeedbackEntries in chronological order.",
                    "\t */",
                    "\tpublic class FeedbackIterator implements Iterator<FeedbackEntry>{",
                    "\t\tprivate int curr;",
                    "\t\t",
                    "\t\tpublic FeedbackIterator()    { curr = 0; }",
                    "\t\tpublic FeedbackEntry next()  { return recordsByTime.get(curr++); }",
                    "\t\tpublic boolean hasNext()     { return curr < recordsByTime.size(); }",
                    "\t\tpublic void remove()  { throw new UnsupportedOperationException(); }",
                    "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t",
                    "\t}",
                    "}"
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr020c66ab.Lecture",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 573
            },
            "evaluatorReader": true,
            "lineCount": 198
        },
        {
            "id": "sectionT7QxrF",
            "type": "section",
            "title": "LectureInitializer",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "LectureInitializer",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.text.ParseException;",
                    "import java.text.SimpleDateFormat;",
                    "import java.util.ArrayList;",
                    "import java.util.Date;",
                    "",
                    "",
                    "public class LectureInitializer {",
                    "",
                    "\tpublic static double mean, stdDev;",
                    "\t",
                    "\tpublic static ArrayList<Lecture> lectures;",
                    "\t",
                    "\tprivate static void addToLecture(Date d, FeedbackEntry entry){",
                    "\t\tif(lectures.size()>0 && lectures.get(lectures.size()-1).getDate().equals(d)){",
                    "\t\t\tlectures.get(lectures.size()-1).add(entry);",
                    "\t\t} else {",
                    "\t\t\tlectures.add(new Lecture(d, entry));",
                    "\t\t}\t",
                    "\t}",
                    "\t",
                    "\tpublic static void initialize(){",
                    "\t\tCleanFeedbackData.initialize();",
                    "\t\tlectures = new ArrayList<>();",
                    "\t\tint[] months = {9,  9,  9,  9,  9,   9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12};",
                    "\t\tint[] days =   {18, 21, 23, 25, 28, 30, 2 ,  5,  7,  9, 12, 14, 16, 19, 21, 23, 26, 28, 30, 02, 04, 06, 9,  11, 13, 16, 18, 20, 30, 2,   4,  7,  9, 31};",
                    "\t\tDate[] lectureDates = new Date[months.length];",
                    "\t\ttry {",
                    "\t\t\tSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");",
                    "\t\t\tfor (int i = 0; i < months.length; ++i){",
                    "\t\t\t\tString toParse = String.format(\"%d-%d-%02d 09:00:00\", 2015, months[i], days[i]);",
                    "\t\t\t\tlectureDates[i] = df.parse(toParse);",
                    "\t\t\t}",
                    "\t\t}",
                    "\t\t",
                    "\t\tcatch(Exception e){",
                    "\t\t\te.printStackTrace();",
                    "\t\t}",
                    "\t\tint currTimeIndex = 0;",
                    "\t\tdouble sum = 0;",
                    "\t\tdouble sumSq = 0;",
                    "\t\tint counter = 0;",
                    "\t\t\t\t",
                    "\t\tfor(int i = 0; i < CleanFeedbackData.clean_data.size(); i++){",
                    "\t\t\t",
                    "\t\t\twhile(CleanFeedbackData.clean_data.get(i).getDate().after(lectureDates[currTimeIndex + 1]))",
                    "\t\t\t\tcurrTimeIndex++;",
                    "\t\t\t",
                    "\t\t\taddToLecture(lectureDates[currTimeIndex], CleanFeedbackData.clean_data.get(i));",
                    "\t\t\tdouble temp = CleanFeedbackData.clean_data.get(i).getGrade();",
                    "\t\t\tsum += temp;",
                    "\t\t\tsumSq += temp*temp;",
                    "\t\t\t++counter;",
                    "\t\t}",
                    "\t\tmean = sum/counter;",
                    "\t\tstdDev = Math.sqrt(sumSq/counter - sum*sum/(counter*counter));",
                    "\t}",
                    "\t",
                    "\tpublic static void main(String[] args) {",
                    "\t\t// TODO Auto-generated method stub",
                    "\t\tSystem.out.println(\"Calling LectureInitializer.initialize()\");",
                    "\t\tinitialize();",
                    "\t\t",
                    "\t\tfor(int j = 0; j < lectures.size(); j++) {",
                    "\t\t\tSystem.out.println(lectures.get(j).toString());",
                    "\t\t\tSystem.out.println(\"\\tRating Distribution:\");",
                    "\t\t\tSystem.out.print(\"\\t\\t\");",
                    "\t\t\t",
                    "\t\t\t//Perhaps this is what you meant? -Bliss",
                    "\t\t\t//int[] values = lectures.get(j).getRatingDistribution();",
                    "\t\t\tint[] values = lectures.get(j).getValues();",
                    "\t\t\tfor(int i = 0; i < values.length; i++) {",
                    "\t\t\t\tSystem.out.print((i + 1) + \": \" + values[i] + \", \");",
                    "\t\t\t}",
                    "\t\t\tSystem.out.println();",
                    "\t\t}",
                    "\t\t",
                    "\t\tSystem.out.printf(\"Average: %f, Standard Deviation: %f\\n\", mean, stdDev);",
                    "\t\tSystem.out.println(\"Number of lectures: \" + lectures.size());",
                    "\t\tSystem.out.println(\"======================================================================================\\n\");",
                    "\t}",
                    "}"
                ]
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr020c66ab.LectureInitializer",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 568
            },
            "evaluatorReader": true,
            "lineCount": 81
        },
        {
            "id": "sectionxMdttn",
            "type": "section",
            "title": "Runner",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "markdownquMZ68",
            "type": "markdown",
            "body": [
                "This runs LectureInitializer"
            ],
            "evaluatorReader": false
        },
        {
            "id": "MainRunner",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "System.out.println(\"Calling LectureInitializer.initialize()\");",
                    "\tLectureInitializer.initialize();",
                    "",
                    "\tfor(int j = 0; j < LectureInitializer.lectures.size(); j++) {",
                    "\t\tSystem.out.println(LectureInitializer.lectures.get(j).toString());",
                    "\t\tSystem.out.println(\"\\tRating Distribution:\");",
                    "\t\tSystem.out.print(\"\\t\\t\");",
                    "\t\t",
                    "\t\t//Perhaps this is what you meant? -Bliss",
                    "\t\t//int[] values = LectureInitializer.lectures.get(j).getRatingDistribution();",
                    "\t\tint[] values = LectureInitializer.lectures.get(j).getValues();",
                    "\t\tfor(int i = 0; i < values.length; i++) {",
                    "\t\t\tSystem.out.print((i + 1) + \": \" + values[i] + \", \");",
                    "\t\t}",
                    "\t\tSystem.out.println();",
                    "\t}",
                    "\t",
                    "\tSystem.out.printf(\"Average: %f, Standard Deviation: %f\\n\", LectureInitializer.mean, LectureInitializer.stdDev);",
                    "\tSystem.out.println(\"Number of lectures: \" + LectureInitializer.lectures.size());",
                    "\tSystem.out.println(\"======================================================================================\\n\");"
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "Results",
                    "outputdata": [
                        {
                            "type": "out",
                            "value": "Calling LectureInitializer.initialize()\nCalling CleanFeedbackData.initialize()\n"
                        }
                    ],
                    "payload": {
                        "type": "BeakerDisplay",
                        "innertype": "Error",
                        "object": [
                            "java.lang.IllegalArgumentException: Can't open file \"/Users/chapman/Documents/workspaceResearch/EncodeNetID/src/roster.txt\" for input.",
                            "(Error :java.io.FileNotFoundException: /Users/chapman/Documents/workspaceResearch/EncodeNetID/src/roster.txt (No such file or directory))",
                            "\tat com.twosigma.beaker.javash.bkr020c66ab.TextIO.readFile(TextIO.java:17)",
                            "\tat com.twosigma.beaker.javash.bkr020c66ab.NRList.fillList(NRList.java:13)",
                            "\tat com.twosigma.beaker.javash.bkr020c66ab.NRList.<init>(NRList.java:13)",
                            "\tat com.twosigma.beaker.javash.bkr020c66ab.CleanFeedbackData.initialize(CleanFeedbackData.java:12)",
                            "\tat com.twosigma.beaker.javash.bkr020c66ab.LectureInitializer.initialize(LectureInitializer.java:15)",
                            "\tat com.twosigma.beaker.javash.bkr020c66ab.Foo.beakerRun(Foo.java:13)",
                            "\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
                            "\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)",
                            "\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)",
                            "\tat java.lang.reflect.Method.invoke(Method.java:497)",
                            "\tat com.twosigma.beaker.javash.utils.JavaEvaluator$workerThread$MyRunnable.run(JavaEvaluator.java:394)",
                            "\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)",
                            "\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)",
                            "\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)",
                            "\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)",
                            "\tat java.lang.Thread.run(Thread.java:745)",
                            ""
                        ]
                    }
                },
                "selectedType": "Results",
                "pluginName": "Java",
                "shellId": "020c66ab-97bc-451d-b073-c29224c73d3e",
                "elapsedTime": 592
            },
            "evaluatorReader": true,
            "lineCount": 20
        }
    ],
    "namespace": {}
}
