{
    "beaker": "2",
    "evaluators": [
        {
            "name": "Html",
            "plugin": "Html",
            "view": {
                "cm": {
                    "mode": "htmlmixed"
                }
            }
        },
        {
            "name": "JavaScript",
            "plugin": "JavaScript",
            "jsSetting2": "",
            "jsSetting1": "",
            "view": {
                "cm": {
                    "mode": "javascript",
                    "background": "#FFE0F0"
                }
            }
        },
        {
            "name": "Java",
            "plugin": "Java",
            "imports": "com.twosigma.beaker.chart.Color\ncom.twosigma.beaker.chart.legend.*\ncom.twosigma.beaker.chart.Filter\ncom.twosigma.beaker.BeakerProgressUpdate\ncom.twosigma.beaker.chart.xychart.*\ncom.twosigma.beaker.chart.xychart.plotitem.*\ncom.twosigma.beaker.NamespaceClient\ncom.twosigma.beaker.easyform.*\ncom.twosigma.beaker.easyform.formitem.*",
            "view": {
                "cm": {
                    "mode": "text/x-java"
                }
            }
        }
    ],
    "cells": [
        {
            "id": "sectionkSa6qT",
            "type": "section",
            "title": "Initializing Data Classes",
            "level": 1,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "sectionqpRoyN",
            "type": "section",
            "title": "TextIO",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "code7ECF0c",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "",
                    "",
                    "import java.io.*;",
                    "import java.util.IllegalFormatException;",
                    "import java.util.regex.Matcher;",
                    "import java.util.regex.Pattern;",
                    "",
                    "import javax.swing.JFileChooser;",
                    "import javax.swing.JOptionPane;",
                    "",
                    "/**",
                    " * TextIO provides a set of static methods for reading and writing text.  By default, it reads",
                    " * from standard input and writes to standard output, but it is possible to redirect the input",
                    " * and output to files or to other input and output streams.  When the standard input and output",
                    " * streams are being used, the input methods will not produce an error; instead, the user is",
                    " * repeatedly prompted for input until a legal input is entered.  (If standard input has been",
                    " * changed externally, as by file redirection on the command line, this is not a reasonable",
                    " * behavior; to handle this case, TextIO will give up after 10 consecutive illegal inputs and",
                    " * will throw an IllegalArgumentException.)  For the most part, any other",
                    " * error will be translated into an IllegalArguementException.",
                    " * <p>For writing to standard output, the output methods in this class pretty much",
                    " * duplicate the functionality of System.out, and System.out can be used interchangeably with them.",
                    " * <p>This class does not use optimal Java programming practices.  It is designed specifically to be easily",
                    " * usable even by a beginning programmer who has not yet learned about objects and exceptions.  Therefore, ",
                    " * everything is in a single source file that compiles into a single class file, all the methods are",
                    " * static methods, and none of the methods throw exceptions that would require try...catch statements.",
                    " * Also for this reason, all exceptions are converted into IllegalArgumentExceptions, even when this",
                    " * exception type doesn't really make sense.",
                    " * <p>This class requires Java 5.0 or higher. (A previous version of TextIO required only Java 1.1;",
                    " * this version should work with any source code that used the previous version, but it has some new",
                    " * features, including the type of formatted output that was introduced in Java 5 and the ability to",
                    " * use files and streams.)",
                    " */",
                    "public class TextIO {",
                    "",
                    "    /* Modified November 2007 to empty the TextIO input buffer when switching from one",
                    "     * input source to another. This fixes a bug that allows input from the previous input",
                    "     * source to be read after the new source has been selected.",
                    "     */",
                    "",
                    "    /**",
                    "     * The value returned by the peek() method when the input is at end-of-file.",
                    "     * (The value of this constant is (char)0xFFFF.)",
                    "     */",
                    "    public final static char EOF = (char)0xFFFF; ",
                    "",
                    "    /**",
                    "     * The value returned by the peek() method when the input is at end-of-line.",
                    "     * The value of this constant is the character '\\n'.",
                    "     */",
                    "    public final static char EOLN = '\\n';          // The value returned by peek() when at end-of-line.",
                    "    ",
                    "",
                    "    /**",
                    "     * After this method is called, input will be read from standard input (as it ",
                    "     * is in the default state).  If a file or stream was previously the input source, that file",
                    "     * or stream is closed.",
                    "     */",
                    "    public static void readStandardInput() {",
                    "        if (readingStandardInput)",
                    "            return;",
                    "        try {",
                    "            in.close();",
                    "        }",
                    "        catch (Exception e) {",
                    "        }",
                    "        emptyBuffer();  // Added November 2007",
                    "        in = standardInput;",
                    "        inputFileName = null;",
                    "        readingStandardInput = true;",
                    "        inputErrorCount = 0;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, input will be read from inputStream, provided it",
                    "     * is non-null.  If inputStream is null, then this method has the same effect",
                    "     * as calling readStandardInput(); that is, future input will come from the",
                    "     * standard input stream.",
                    "     */",
                    "    public static void readStream(InputStream inputStream) {",
                    "        if (inputStream == null)",
                    "            readStandardInput();",
                    "        else",
                    "            readStream(new InputStreamReader(inputStream));",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, input will be read from inputStream, provided it",
                    "     * is non-null.  If inputStream is null, then this method has the same effect",
                    "     * as calling readStandardInput(); that is, future input will come from the",
                    "     * standard input stream.",
                    "     */",
                    "    public static void readStream(Reader inputStream) {",
                    "        if (inputStream == null)",
                    "            readStandardInput();",
                    "        else {",
                    "            if ( inputStream instanceof BufferedReader)",
                    "                in = (BufferedReader)inputStream;",
                    "            else",
                    "                in = new BufferedReader(inputStream);",
                    "            emptyBuffer();  // Added November 2007",
                    "            inputFileName = null;",
                    "            readingStandardInput = false;",
                    "            inputErrorCount = 0;",
                    "        }",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Opens a file with a specified name for input.  If the file name is null, this has",
                    "     * the same effect as calling readStandardInput(); that is, input will be read from standard",
                    "     * input.  If an",
                    "     * error occurs while trying to open the file, an exception of type IllegalArgumentException",
                    "     * is thrown, and the input source is not changed.  If the file is opened ",
                    "     * successfully, then after this method is called, all of the input routines will read ",
                    "     * from the file, instead of from standard input.",
                    "     */",
                    "    public static void readFile(String fileName) {",
                    "        if (fileName == null) // Go back to reading standard input",
                    "            readStandardInput();",
                    "        else {",
                    "            BufferedReader newin;",
                    "            try {",
                    "                newin = new BufferedReader( new FileReader(fileName) );",
                    "            }",
                    "            catch (Exception e) {",
                    "                throw new IllegalArgumentException(\"Can't open file \\\"\" + fileName + \"\\\" for input.\\n\"",
                    "                                 + \"(Error :\" + e + \")\");",
                    "            }",
                    "            if (! readingStandardInput) { // close current input stream",
                    "                try {",
                    "                    in.close();",
                    "                }",
                    "                catch (Exception e) {",
                    "                }",
                    "            }",
                    "            emptyBuffer();  // Added November 2007",
                    "            in = newin;",
                    "            readingStandardInput = false;",
                    "            inputErrorCount = 0;",
                    "            inputFileName = fileName;",
                    "        }",
                    "    }",
                    "",
                    "    /**",
                    "     * Puts a GUI file-selection dialog box on the screen in which the user can select",
                    "     * an input file.  If the user cancels the dialog instead of selecting a file, it is",
                    "     * not considered an error, but the return value of the subroutine is false.",
                    "     * If the user does select a file, but there is an error while trying to open the",
                    "     * file, then an exception of type IllegalArgumentException is thrown.  Finally, if",
                    "     * the user selects a file and it is successfully opened, then the return value of the",
                    "     * subroutine is true, and  the input routines will read from the file, instead of ",
                    "     * from standard input.   If the user cancels, or if any error occurs, then the",
                    "     * previous input source is not changed.",
                    "     * <p>NOTE: Calling this method starts a GUI user interface thread, which can continue",
                    "     * to run even if the thread that runs the main program ends.  If you use this method",
                    "     * in a non-GUI program, it might be necessary to call System.exit(0) at the end of the main() ",
                    "     * routine to shut down the Java virtual machine completely.",
                    "     */",
                    "    public static boolean readUserSelectedFile() {",
                    "        if (fileDialog == null)",
                    "            fileDialog = new JFileChooser();",
                    "        fileDialog.setDialogTitle(\"Select File for Input\");",
                    "        int option = fileDialog.showOpenDialog(null);",
                    "        if (option != JFileChooser.APPROVE_OPTION)",
                    "            return false;",
                    "        File selectedFile = fileDialog.getSelectedFile();",
                    "        BufferedReader newin;",
                    "        try {",
                    "            newin = new BufferedReader( new FileReader(selectedFile) );",
                    "        }",
                    "        catch (Exception e) {",
                    "            throw new IllegalArgumentException(\"Can't open file \\\"\" + selectedFile.getName() + \"\\\" for input.\\n\"",
                    "                             + \"(Error :\" + e + \")\");",
                    "        }",
                    "        if (!readingStandardInput) { // close current file",
                    "            try {",
                    "                in.close();",
                    "            }",
                    "            catch (Exception e) {",
                    "            }",
                    "        }",
                    "        emptyBuffer();  // Added November 2007",
                    "        in = newin;",
                    "        inputFileName = selectedFile.getName();",
                    "        readingStandardInput = false;",
                    "        inputErrorCount = 0;",
                    "        return true;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, output will be written to standard output (as it ",
                    "     * is in the default state).  If a file or stream was previously open for output, it",
                    "     * will be closed.",
                    "     */",
                    "    public static void writeStandardOutput() {",
                    "        if (writingStandardOutput)",
                    "            return;",
                    "        try {",
                    "            out.close();",
                    "        }",
                    "        catch (Exception e) {",
                    "        }",
                    "        outputFileName = null;",
                    "        outputErrorCount = 0;",
                    "        out = standardOutput;",
                    "        writingStandardOutput = true;",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * After this method is called, output will be sent to outputStream, provided it",
                    "     * is non-null.  If outputStream is null, then this method has the same effect",
                    "     * as calling writeStandardOutput(); that is, future output will be sent to the",
                    "     * standard output stream.",
                    "     */",
                    "    public static void writeStream(OutputStream outputStream) {",
                    "        if (outputStream == null)",
                    "            writeStandardOutput();",
                    "        else",
                    "            writeStream(new PrintWriter(outputStream));",
                    "    }",
                    "    ",
                    "    /**",
                    "     * After this method is called, output will be sent to outputStream, provided it",
                    "     * is non-null.  If outputStream is null, then this method has the same effect",
                    "     * as calling writeStandardOutput(); that is, future output will be sent to the",
                    "     * standard output stream.",
                    "     */",
                    "    public static void writeStream(PrintWriter outputStream) {",
                    "        if (outputStream == null)",
                    "            writeStandardOutput();",
                    "        else {",
                    "            out = outputStream;",
                    "            outputFileName = null;",
                    "            outputErrorCount = 0;",
                    "            writingStandardOutput = false;",
                    "        }",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * Opens a file with a specified name for output.  If the file name is null, this has",
                    "     * the same effect as calling writeStandardOutput(); that is, output will be sent to standard",
                    "     * output.  If an",
                    "     * error occurs while trying to open the file, an exception of type IllegalArgumentException",
                    "     * is thrown.  If the file is opened successfully, then after this method is called,",
                    "     * all of the output routines will write to the file, instead of to  standard output.",
                    "     * If an error occurs, the output destination is not changed.",
                    "     * <p>NOTE: Calling this method starts a GUI user interface thread, which can continue",
                    "     * to run even if the thread that runs the main program ends.  If you use this method",
                    "     * in a non-GUI program, it might be necessary to call System.exit(0) at the end of the main() ",
                    "     * routine to shut down the Java virtual machine completely.",
                    "     */",
                    "    public static void writeFile(String fileName) {",
                    "        if (fileName == null)  // Go back to reading standard output",
                    "            writeStandardOutput();",
                    "        else {",
                    "            PrintWriter newout;",
                    "            try {",
                    "                newout = new PrintWriter(new FileWriter(fileName));",
                    "            }",
                    "            catch (Exception e) {",
                    "                throw new IllegalArgumentException(\"Can't open file \\\"\" + fileName + \"\\\" for output.\\n\"",
                    "                                 + \"(Error :\" + e + \")\");",
                    "            }",
                    "            if (!writingStandardOutput) {",
                    "                try {",
                    "                    out.close();",
                    "                }",
                    "                catch (Exception e) {",
                    "                }",
                    "            }",
                    "            out = newout;",
                    "            writingStandardOutput = false;",
                    "            outputFileName = fileName;",
                    "            outputErrorCount = 0;",
                    "        }",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Puts a GUI file-selection dialog box on the screen in which the user can select",
                    "     * an output file.  If the user cancels the dialog instead of selecting a file, it is",
                    "     * not considered an error, but the return value of the subroutine is false.",
                    "     * If the user does select a file, but there is an error while trying to open the",
                    "     * file, then an exception of type IllegalArgumentException is thrown.  Finally, if",
                    "     * the user selects a file and it is successfully opened, then the return value of the",
                    "     * subroutine is true, and  the output routines will write to the file, instead of ",
                    "     * to standard output.  If the user cancels, or if an error occurs, then the current",
                    "     * output destination is not changed.",
                    "     */",
                    "    public static boolean writeUserSelectedFile() {",
                    "        if (fileDialog == null)",
                    "            fileDialog = new JFileChooser();",
                    "        fileDialog.setDialogTitle(\"Select File for Output\");",
                    "        File selectedFile;",
                    "        while (true) {",
                    "            int option = fileDialog.showSaveDialog(null);",
                    "            if (option != JFileChooser.APPROVE_OPTION)",
                    "                return false;  // user canceled",
                    "            selectedFile = fileDialog.getSelectedFile();",
                    "            if (selectedFile.exists()) {",
                    "                int response = JOptionPane.showConfirmDialog(null,",
                    "                        \"The file \\\"\" + selectedFile.getName() + \"\\\" already exists.  Do you want to replace it?\",",
                    "                        \"Replace existing file?\",",
                    "                        JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);",
                    "                if (response == JOptionPane.YES_OPTION)",
                    "                    break;",
                    "            }",
                    "            else {",
                    "                break;",
                    "            }",
                    "        }",
                    "        PrintWriter newout;",
                    "        try {",
                    "            newout = new PrintWriter(new FileWriter(selectedFile));",
                    "        }",
                    "        catch (Exception e) {",
                    "            throw new IllegalArgumentException(\"Can't open file \\\"\" + selectedFile.getName() + \"\\\" for output.\\n\"",
                    "                             + \"(Error :\" + e + \")\");",
                    "        }",
                    "        if (!writingStandardOutput) {",
                    "            try {",
                    "                out.close();",
                    "            }",
                    "            catch (Exception e) {",
                    "            }",
                    "        }",
                    "        out = newout;",
                    "        writingStandardOutput = false;",
                    "        outputFileName = selectedFile.getName();",
                    "        outputErrorCount = 0;",
                    "        return true;",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * If TextIO is currently reading from a file, then the return value is the name of the file.  ",
                    "     * If the class is reading from standard input or from a stream, then the return value is null.",
                    "     */",
                    "    public static String getInputFileName() {",
                    "        return inputFileName;",
                    "    }",
                    "    ",
                    "",
                    "    /**",
                    "     * If TextIO is currently writing to a file, then the return value is the name of the file.  ",
                    "     * If the class is writing to standard output or to a stream, then the return value is null.",
                    "     */",
                    "    public static String getOutputFileName() {",
                    "        return outputFileName;",
                    "    }",
                    "    ",
                    "",
                    "    // *************************** Output Methods *********************************",
                    "        ",
                    "    /**",
                    "     * Write a single value to the current output destination, using the default format",
                    "     * and no extra spaces.  This method will handle any type of parameter, even one",
                    "     * whose type is one of the primitive types.",
                    "     */",
                    "    public static void put(Object x) { ",
                    "        out.print(x); ",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Write a single value to the current output destination, using the default format",
                    "     * and outputting at least minChars characters (with extra spaces added before the",
                    "     * output value if necessary).  This method will handle any type of parameter, even one",
                    "     * whose type is one of the primitive types.",
                    "     * @param x The value to be output, which can be of any type.",
                    "     * @param minChars The minimum number of characters to use for the output.  If x requires fewer",
                    "     * then this number of characters, then extra spaces are added to the front of x to bring",
                    "     * the total up to minChars.  If minChars is less than or equal to zero, then x will be printed",
                    "     * in the minimum number of spaces possible.",
                    "     */",
                    "    public static void put(Object x, int minChars)  { ",
                    "        if (minChars <= 0)",
                    "            out.print(x);",
                    "        else",
                    "            out.printf(\"%\" + minChars + \"s\", x);",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "        ",
                    "    /**",
                    "     * This is equivalent to put(x), followed by an end-of-line.",
                    "     */",
                    "    public static void putln(Object x) { ",
                    "        out.println(x);",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    /**",
                    "     * This is equivalent to put(x,minChars), followed by an end-of-line.",
                    "     */",
                    "    public static void putln(Object x, int minChars) {",
                    "        put(x,minChars);",
                    "        out.println();",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "",
                    "    /**",
                    "     * Write an end-of-line character to the current output destination.",
                    "     */",
                    "    public static void putln() {",
                    "        out.println();",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Writes formatted output values to the current output destination.  This method has the",
                    "     * same function as System.out.printf(); the details of formatted output are not discussed",
                    "     * here.  The first parameter is a string that describes the format of the output.  There",
                    "     * can be any number of additional parameters; these specify the values to be output and",
                    "     * can be of any type.  This method will throw an IllegalArgumentException if the",
                    "     * format string is null or if the format string is illegal for the values that are being",
                    "     * output.",
                    "     */",
                    "    public static void putf(String format, Object... items) {",
                    "        if (format == null)",
                    "            throw new IllegalArgumentException(\"Null format string in TextIO.putf() method.\");",
                    "        try {",
                    "            out.printf(format,items);",
                    "        }",
                    "        catch (IllegalFormatException e) {",
                    "            throw new IllegalArgumentException(\"Illegal format string in TextIO.putf() method.\");",
                    "        }",
                    "        out.flush();",
                    "        if (out.checkError())",
                    "            outputError(\"Error while writing output.\");",
                    "    }",
                    "    ",
                    "    // *************************** Input Methods *********************************",
                    "",
                    "    /**",
                    "     * Test whether the next character in the current input source is an end-of-line.  Note that",
                    "     * this method does NOT skip whitespace before testing for end-of-line -- if you want to do",
                    "     * that, call skipBlanks() first.",
                    "     */",
                    "    public static boolean eoln() { ",
                    "        return peek() == '\\n'; ",
                    "    }",
                    "",
                    "    /**",
                    "     * Test whether the next character in the current input source is an end-of-file.  Note that",
                    "     * this method does NOT skip whitespace before testing for end-of-line -- if you want to do",
                    "     * that, call skipBlanks() or skipWhitespace() first.",
                    "     */",
                    "    public static boolean eof()  { ",
                    "        return peek() == EOF; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Reads the next character from the current input source.  The character can be a whitespace",
                    "     * character; compare this to the getChar() method, which skips over whitespace and returns the",
                    "     * next non-whitespace character.  An end-of-line is always returned as the character '\\n', even",
                    "     * when the actual end-of-line in the input source is something else, such as '\\r' or \"\\r\\n\".",
                    "     * This method will throw an IllegalArgumentException if the input is at end-of-file (which will ",
                    "     * not ordinarily happen if reading from standard input).",
                    "     */",
                    "    public static char getAnyChar() { ",
                    "        return readChar(); ",
                    "    }",
                    "",
                    "    /**",
                    "     * Returns the next character in the current input source, without actually removing that",
                    "     * character from the input.  The character can be a whitespace character and can be the",
                    "     * end-of-file character (specified by the constant TextIO.EOF).An end-of-line is always returned ",
                    "     * as the character '\\n', even when the actual end-of-line in the input source is something else, ",
                    "     * such as '\\r' or \"\\r\\n\".  This method never causes an error.",
                    "     */",
                    "    public static char peek() { ",
                    "        return lookChar();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips over any whitespace characters, except for end-of-lines.  After this method is called,",
                    "     * the next input character is either an end-of-line, an end-of-file, or a non-whitespace character.",
                    "     * This method never causes an error.  (Ordinarily, end-of-file is not possible when reading from",
                    "     * standard input.)",
                    "     */",
                    "    public static void skipBlanks() { ",
                    "        char ch=lookChar();",
                    "        while (ch != EOF && ch != '\\n' && Character.isWhitespace(ch)) {",
                    "            readChar();",
                    "            ch = lookChar();",
                    "        }",
                    "    }",
                    "",
                    "    /**",
                    "     * Skips over any whitespace characters, including for end-of-lines.  After this method is called,",
                    "     * the next input character is either an end-of-file or a non-whitespace character.",
                    "     * This method never causes an error. (Ordinarily, end-of-file is not possible when reading from",
                    "     * standard input.)",
                    "     */",
                    "    private static void skipWhitespace() {",
                    "        char ch=lookChar();",
                    "        while (ch != EOF && Character.isWhitespace(ch)) {",
                    "            readChar();",
                    "            if (ch == '\\n' && readingStandardInput && writingStandardOutput) {",
                    "                out.print(\"? \");",
                    "                out.flush();",
                    "            }",
                    "            ch = lookChar();",
                    "        }",
                    "    }",
                    "",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type byte from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static byte getlnByte() { ",
                    "        byte x=getByte(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type short from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static short getlnShort() {",
                    "        short x=getShort();",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type int from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static int getlnInt() { ",
                    "        int x=getInt(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type long from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static long getlnLong() {",
                    "        long x=getLong(); ",
                    "        emptyBuffer(); ",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type float from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static float getlnFloat() {",
                    "        float x=getFloat(); ",
                    "        emptyBuffer(); ",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type double from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static double getlnDouble() { ",
                    "        double x=getDouble(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type char from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  Note that the value",
                    "     * that is returned will be a non-whitespace character; compare this with the getAnyChar() method.",
                    "     * When using standard IO, this will not produce an error.  In other cases, an error can occur if",
                    "     * an end-of-file is encountered.",
                    "     */",
                    "    public static char getlnChar() {",
                    "        char x=getChar(); ",
                    "        emptyBuffer(); ",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type boolean from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     * <p>Legal inputs for a boolean input are: true, t, yes, y, 1, false, f, no, n, and 0; letters can be",
                    "     * either upper case or lower case. One \"word\" of input is read, using the getWord() method, and it",
                    "     * must be one of these; note that the \"word\"  must be terminated by a whitespace character (or end-of-file).",
                    "     */",
                    "    public static boolean getlnBoolean() { ",
                    "        boolean x=getBoolean(); ",
                    "        emptyBuffer();",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads one \"word\" from input, discarding the rest of ",
                    "     * the current line of input (including the next end-of-line character, if any).  A word is defined as",
                    "     * a sequence of non-whitespace characters (not just letters!).   When using standard IO,",
                    "     * this will not produce an error.  In other cases, an IllegalArgumentException will be thrown",
                    "     * if an end-of-file is encountered.",
                    "     */",
                    "    public static String getlnWord() {",
                    "        String x=getWord(); ",
                    "        emptyBuffer(); ",
                    "        return x; ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * This is identical to getln().",
                    "     */",
                    "    public static String getlnString() {",
                    "        return getln();",
                    "    } ",
                    "    ",
                    "    /**",
                    "     * Reads all the characters from the current input source, up to the next end-of-line.  The end-of-line",
                    "     * is read but is not included in the return value.  Any other whitespace characters on the line are retained,",
                    "     * even if they occur at the start of input.  The return value will be an empty string if there are",
                    "     * no characters before the end-of-line.  When using standard IO, this will not produce an error.  ",
                    "     * In other cases, an IllegalArgumentException will be thrown if an end-of-file is encountered.",
                    "     */",
                    "    public static String getln() {",
                    "        StringBuffer s = new StringBuffer(100);",
                    "        char ch = readChar();",
                    "        while (ch != '\\n') {",
                    "            s.append(ch);",
                    "            ch = readChar();",
                    "        }",
                    "        return s.toString();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type byte from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static byte getByte()   { ",
                    "        return (byte)readInteger(-128L,127L); ",
                    "    }",
                    "",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type short from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static short getShort() { ",
                    "        return (short)readInteger(-32768L,32767L);",
                    "    }   ",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type int from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static int getInt()     { ",
                    "        return (int)readInteger(Integer.MIN_VALUE, Integer.MAX_VALUE);",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type long from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static long getLong()   { ",
                    "        return readInteger(Long.MIN_VALUE, Long.MAX_VALUE); ",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a single non-whitespace character from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error.  In other cases, an IllegalArgumentException will be thrown if an end-of-file",
                    "     * is encountered.",
                    "     */",
                    "    public static char getChar() { ",
                    "        skipWhitespace();",
                    "        return readChar();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type float from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static float getFloat() {",
                    "        float x = 0.0F;",
                    "        while (true) {",
                    "            String str = readRealString();",
                    "            if (str == null) {",
                    "                errorMessage(\"Floating point number not found.\",",
                    "                        \"Real number in the range \" + (-Float.MAX_VALUE) + \" to \" + Float.MAX_VALUE);",
                    "            }",
                    "            else {",
                    "                try { ",
                    "                    x = Float.parseFloat(str); ",
                    "                }",
                    "                catch (NumberFormatException e) {",
                    "                    errorMessage(\"Illegal floating point input, \" + str + \".\",",
                    "                            \"Real number in the range \" +  (-Float.MAX_VALUE) + \" to \" + Float.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                if (Float.isInfinite(x)) {",
                    "                    errorMessage(\"Floating point input outside of legal range, \" + str + \".\",",
                    "                            \"Real number in the range \" +  (-Float.MAX_VALUE) + \" to \" + Float.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                break;",
                    "            }",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type double from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     */",
                    "    public static double getDouble() {",
                    "        double x = 0.0;",
                    "        while (true) {",
                    "            String str = readRealString();",
                    "            if (str == null) {",
                    "                errorMessage(\"Floating point number not found.\",",
                    "                        \"Real number in the range \" + (-Double.MAX_VALUE) + \" to \" + Double.MAX_VALUE);",
                    "            }",
                    "            else {",
                    "                try { ",
                    "                    x = Double.parseDouble(str); ",
                    "                }",
                    "                catch (NumberFormatException e) {",
                    "                    errorMessage(\"Illegal floating point input, \" + str + \".\",",
                    "                            \"Real number in the range \" + (-Double.MAX_VALUE) + \" to \" + Double.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                if (Double.isInfinite(x)) {",
                    "                    errorMessage(\"Floating point input outside of legal range, \" + str + \".\",",
                    "                            \"Real number in the range \" + (-Double.MAX_VALUE) + \" to \" + Double.MAX_VALUE);",
                    "                    continue;",
                    "                }",
                    "                break;",
                    "            }",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return x;",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads one \"word\" from input. Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  A word is defined as",
                    "     * a sequence of non-whitespace characters (not just letters!).   When using standard IO,",
                    "     * this will not produce an error.  In other cases, an IllegalArgumentException will be thrown",
                    "     * if an end-of-file is encountered.",
                    "     */",
                    "    public static String getWord() {",
                    "        skipWhitespace();",
                    "        StringBuffer str = new StringBuffer(50);",
                    "        char ch = lookChar();",
                    "        while (ch == EOF || !Character.isWhitespace(ch)) {",
                    "            str.append(readChar());",
                    "            ch = lookChar();",
                    "        }",
                    "        return str.toString();",
                    "    }",
                    "    ",
                    "    /**",
                    "     * Skips whitespace characters and then reads a value of type boolean from input.  Any additional characters on",
                    "     * the current line of input are retained, and will be read by the next input operation.  When using standard IO,",
                    "     * this will not produce an error; the user will be prompted repeatedly for input until a legal value",
                    "     * is input.  In other cases, an IllegalArgumentException will be thrown if a legal value is not found.",
                    "     * <p>Legal inputs for a boolean input are: true, t, yes, y, 1, false, f, no, n, and 0; letters can be",
                    "     * either upper case or lower case. One \"word\" of input is read, using the getWord() method, and it",
                    "     * must be one of these; note that the \"word\"  must be terminated by a whitespace character (or end-of-file).",
                    "     */",
                    "    public static boolean getBoolean() {",
                    "        boolean ans = false;",
                    "        while (true) {",
                    "            String s = getWord();",
                    "            if ( s.equalsIgnoreCase(\"true\") || s.equalsIgnoreCase(\"t\") ||",
                    "                    s.equalsIgnoreCase(\"yes\")  || s.equalsIgnoreCase(\"y\") ||",
                    "                    s.equals(\"1\") ) {",
                    "                ans = true;",
                    "                break;",
                    "            }",
                    "            else if ( s.equalsIgnoreCase(\"false\") || s.equalsIgnoreCase(\"f\") ||",
                    "                    s.equalsIgnoreCase(\"no\")  || s.equalsIgnoreCase(\"n\") ||",
                    "                    s.equals(\"0\") ) {",
                    "                ans = false;",
                    "                break;",
                    "            }",
                    "            else",
                    "                errorMessage(\"Illegal boolean input value.\",",
                    "                \"one of:  true, false, t, f, yes, no, y, n, 0, or 1\");",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return ans;",
                    "    }",
                    "    ",
                    "    // ***************** Everything beyond this point is private implementation detail *******************",
                    "    ",
                    "    private static String inputFileName;  // Name of file that is the current input source, or null if the source is not a file.",
                    "    private static String outputFileName; // Name of file that is the current output destination, or null if the destination is not a file.",
                    "    ",
                    "    private static JFileChooser fileDialog; // Dialog used by readUserSelectedFile() and writeUserSelectedFile()",
                    "    ",
                    "    private final static BufferedReader standardInput = new BufferedReader(new InputStreamReader(System.in));  // wraps standard input stream",
                    "    private final static PrintWriter standardOutput = new PrintWriter(System.out);  // wraps standard output stream",
                    "",
                    "    private static BufferedReader in = standardInput;  // Stream that data is read from; the current input source.",
                    "    private static PrintWriter out = standardOutput;   // Stream that data is written to; the current output destination.",
                    "    ",
                    "    private static boolean readingStandardInput = true;",
                    "    private static boolean writingStandardOutput = true;",
                    "    ",
                    "    private static int inputErrorCount;  // Number of consecutive errors on standard input; reset to 0 when a successful read occurs.",
                    "    private static int outputErrorCount;  // Number of errors on standard output since it was selected as the output destination.",
                    "    ",
                    "    private static Matcher integerMatcher;  // Used for reading integer numbers; created from the integer Regex Pattern.",
                    "    private static Matcher floatMatcher;   // Used for reading floating point numbers; created from the floatRegex Pattern.",
                    "    private final static Pattern integerRegex = Pattern.compile(\"(\\\\+|-)?[0-9]+\");",
                    "    private final static Pattern floatRegex = Pattern.compile(\"(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))((e|E)(\\\\+|-)?[0-9]+)?\");",
                    "    ",
                    "    private static String buffer = null;  // One line read from input.",
                    "    private static int pos = 0;           // Position of next char in input line that has not yet been processed.",
                    "    ",
                    "    private static String readRealString() {   // read chars from input following syntax of real numbers",
                    "        skipWhitespace();",
                    "        if (lookChar() == EOF)",
                    "            return null;",
                    "        if (floatMatcher == null)",
                    "            floatMatcher = floatRegex.matcher(buffer);",
                    "        floatMatcher.region(pos,buffer.length());",
                    "        if (floatMatcher.lookingAt()) {",
                    "            String str = floatMatcher.group();",
                    "            pos = floatMatcher.end();",
                    "            return str;",
                    "        }",
                    "        else ",
                    "            return null;",
                    "    }",
                    "    ",
                    "    private static String readIntegerString() {  // read chars from input following syntax of integers",
                    "        skipWhitespace();",
                    "        if (lookChar() == EOF)",
                    "            return null;",
                    "        if (integerMatcher == null)",
                    "            integerMatcher = integerRegex.matcher(buffer);",
                    "        integerMatcher.region(pos,buffer.length());",
                    "        if (integerMatcher.lookingAt()) {",
                    "            String str = integerMatcher.group();",
                    "            pos = integerMatcher.end();",
                    "            return str;",
                    "        }",
                    "        else ",
                    "            return null;",
                    "    }",
                    "    ",
                    "    private static long readInteger(long min, long max) {  // read long integer, limited to specified range",
                    "        long x=0;",
                    "        while (true) {",
                    "            String s = readIntegerString();",
                    "            if (s == null){",
                    "                errorMessage(\"Integer value not found in input.\",",
                    "                        \"Integer in the range \" + min + \" to \" + max);",
                    "            }",
                    "            else {",
                    "                String str = s.toString();",
                    "                try { ",
                    "                    x = Long.parseLong(str);",
                    "                }",
                    "                catch (NumberFormatException e) {",
                    "                    errorMessage(\"Illegal integer input, \" + str + \".\",",
                    "                            \"Integer in the range \" + min + \" to \" + max);",
                    "                    continue;",
                    "                }",
                    "                if (x < min || x > max) {",
                    "                    errorMessage(\"Integer input outside of legal range, \" + str + \".\",",
                    "                            \"Integer in the range \" + min + \" to \" + max);",
                    "                    continue;",
                    "                }",
                    "                break;",
                    "            }",
                    "        }",
                    "        inputErrorCount = 0;",
                    "        return x;",
                    "    }",
                    "    ",
                    "    ",
                    "    private static void errorMessage(String message, String expecting) {  // Report error on input.",
                    "        if (readingStandardInput && writingStandardOutput) {",
                    "                // inform user of error and force user to re-enter.",
                    "            out.println();",
                    "            out.print(\"  *** Error in input: \" + message + \"\\n\");",
                    "            out.print(\"  *** Expecting: \" + expecting + \"\\n\");",
                    "            out.print(\"  *** Discarding Input: \");",
                    "            if (lookChar() == '\\n')",
                    "                out.print(\"(end-of-line)\\n\\n\");",
                    "            else {",
                    "                while (lookChar() != '\\n')    // Discard and echo remaining chars on the current line of input.",
                    "                    out.print(readChar());",
                    "                out.print(\"\\n\\n\");",
                    "            }",
                    "            out.print(\"Please re-enter: \");",
                    "            out.flush();",
                    "            readChar();  // discard the end-of-line character",
                    "            inputErrorCount++;",
                    "            if (inputErrorCount >= 10)",
                    "                throw new IllegalArgumentException(\"Too many input consecutive input errors on standard input.\");",
                    "        }",
                    "        else if (inputFileName != null)",
                    "            throw new IllegalArgumentException(\"Error while reading from file \\\"\" + inputFileName + \"\\\":\\n\" ",
                    "                    + message + \"\\nExpecting \" + expecting);",
                    "        else",
                    "            throw new IllegalArgumentException(\"Error while reading from inptu stream:\\n\" ",
                    "                    + message + \"\\nExpecting \" + expecting);",
                    "    }",
                    "    ",
                    "    private static char lookChar() {  // return next character from input",
                    "        if (buffer == null || pos > buffer.length())",
                    "            fillBuffer();",
                    "        if (buffer == null)",
                    "            return EOF;",
                    "        else if (pos == buffer.length())",
                    "            return '\\n';",
                    "        else ",
                    "            return buffer.charAt(pos);",
                    "    }",
                    "    ",
                    "    private static char readChar() {  // return and discard next character from input",
                    "        char ch = lookChar();",
                    "        if (buffer == null) {",
                    "            if (readingStandardInput)",
                    "                throw new IllegalArgumentException(\"Attempt to read past end-of-file in standard input???\");",
                    "            else",
                    "                throw new IllegalArgumentException(\"Attempt to read past end-of-file in file \\\"\" + inputFileName + \"\\\".\");",
                    "        }",
                    "        pos++;",
                    "        return ch;",
                    "    }",
                    "        ",
                    "    private static void fillBuffer() {    // Wait for user to type a line and press return,",
                    "        try {",
                    "            buffer = in.readLine();",
                    "        }",
                    "        catch (Exception e) {",
                    "            if (readingStandardInput)",
                    "                throw new IllegalArgumentException(\"Error while reading standard input???\");",
                    "            else if (inputFileName != null)",
                    "                throw new IllegalArgumentException(\"Error while attempting to read from file \\\"\" + inputFileName + \"\\\".\");",
                    "            else",
                    "                throw new IllegalArgumentException(\"Errow while attempting to read form an input stream.\");",
                    "        }",
                    "        pos = 0;",
                    "        floatMatcher = null;",
                    "        integerMatcher = null;",
                    "    }",
                    "    ",
                    "    private static void emptyBuffer() {   // discard the rest of the current line of input",
                    "        buffer = null;",
                    "    }",
                    "    ",
                    "    private static void outputError(String message) {  // Report an error on output.",
                    "        if (writingStandardOutput) {",
                    "            System.err.println(\"Error occurred in TextIO while writing to standard output!!\");",
                    "            outputErrorCount++;",
                    "            if (outputErrorCount >= 10) {",
                    "                outputErrorCount = 0;",
                    "                throw new IllegalArgumentException(\"Too many errors while writing to standard output.\");",
                    "            }",
                    "        }",
                    "        else if (outputFileName != null){",
                    "            throw new IllegalArgumentException(\"Error occurred while writing to file \\\"\" ",
                    "                    + outputFileName+ \"\\\":\\n   \" + message);",
                    "        }",
                    "        else {",
                    "            throw new IllegalArgumentException(\"Error occurred while writing to output stream:\\n   \" + message);",
                    "        }",
                    "    }",
                    "        ",
                    "} // end of class TextIO"
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr28670c17.TextIO",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "28670c17-eed5-4f75-811e-b172fdbb2c75",
                "elapsedTime": 643
            },
            "evaluatorReader": true,
            "lineCount": 1008,
            "initialization": true
        },
        {
            "id": "sectionkeHbFD",
            "type": "section",
            "title": "NetIDPair",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codeUp1WEE",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.Arrays;",
                    "",
                    "/**",
                    " *  A simple pair POD that assigns a random number to a NetID",
                    " *  and stores the two.",
                    " *  @author CS125 Research",
                    " */",
                    "public class NetIDPair {",
                    "\tprivate String netID;",
                    "\tprivate int random;",
                    "\t",
                    "\t/**",
                    "\t * Struct constructor.",
                    "\t * ",
                    "\t * @param newNetid   NetID of student.",
                    "\t * @param newRandom  Random code associated with this NetID.",
                    "\t */",
                    "\tpublic NetIDPair(String newNetID, int newRandom){",
                    "\t\tnetID = newNetID;",
                    "\t\trandom = newRandom;\t",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return The code associated with this netID.",
                    "\t */\t",
                    "\tpublic int getRandom() { return random; }",
                    "\t",
                    "\t/**",
                    "\t * @return The string representation of this pair. Just a comma",
                    " \t *         separated juxtaposition of netID and code.",
                    "\t */",
                    "\tpublic String toString(){",
                    "\t\tchar[] build = new char[netID.length()];",
                    "\t\tArrays.fill(build, '*');",
                    "\t\tbuild[0] = netID.charAt(0);",
                    "\t\tint last = netID.length()-1;",
                    "\t\tbuild[last] = netID.charAt(last);",
                    "\t\treturn (new String(build)) + \": \" + random;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return True iff searchID matches this NetIDPair's netID.",
                    "\t */",
                    "\tpublic boolean equals(String searchID){",
                    "\t\treturn this.netID.equals(searchID);",
                    "\t}",
                    "\t",
                    "}",
                    ""
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr28670c17.NetIDPair",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "28670c17-eed5-4f75-811e-b172fdbb2c75",
                "elapsedTime": 53
            },
            "evaluatorReader": true,
            "lineCount": 49,
            "initialization": true
        },
        {
            "id": "sectionsR1i5J",
            "type": "section",
            "title": "NRList",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": true
        },
        {
            "id": "codebCB7W8",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.util.ArrayList;",
                    "import java.util.Iterator;",
                    "/**",
                    " *  A simple map-like list of NetIDPairs with a file argument constructor.",
                    " *  Can return the code associated with a particular netID passed into its",
                    " *  getSecret() method.",
                    " *  @author CS125 Research",
                    " */",
                    "public class NRList implements Iterable<NetIDPair>{",
                    "\t",
                    "\t/** A list of all NetIDPairs extracted from the roster */",
                    "\tArrayList <NetIDPair> pairList = new ArrayList<NetIDPair>();",
                    "\t",
                    "\t/**",
                    "\t * File argument constructor. Reads input file and fills up data",
                    "\t * structure with NetIDPair objects from the file.",
                    "\t *",
                    "\t * @param inFile  The name of the file from which we read netIDs.",
                    "\t * @param outFile Debug output file.",
                    "\t * @param range   Range element for NetIDPair random generator.",
                    "\t */",
                    "\tpublic NRList(String inFile, String outFile, int range){",
                    "\t\tfillList(inFile, outFile, range);",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Helper function for constructor that does all the work.",
                    "\t * Takes in filenames to get a source of NetIDs and a",
                    "\t * range to determine the range of ID codes assigned. Also used",
                    "\t * to add new NetIDPairs to an existing NRList.",
                    "\t * ",
                    "\t * @param readFilePath The source file for all NetIDs.",
                    "\t * @param range        Upper bound on ID code assigned.",
                    "\t */",
                    "\tpublic void fillList(String readFilePath, String writeFilePath, int range)",
                    "\t{",
                    "\t\tTextIO.readFile(readFilePath);",
                    "\t\t",
                    "\t\tif (writeFilePath != null)",
                    "\t\t\tTextIO.writeFile(writeFilePath);",
                    "\t\t",
                    "\t\twhile(!TextIO.eof())",
                    "\t\t{",
                    "\t\t\tString line = TextIO.getln();",
                    "\t\t\tString netID = line.split(\",\")[1];",
                    "\t\t\tNetIDPair potentialPair;",
                    "\t\t\t",
                    "\t\t\tdo{",
                    "\t\t\t\tint randomID = (int)(Math.random()*range);",
                    "\t\t\t\tpotentialPair = new NetIDPair(netID,randomID);",
                    "\t\t\t} while(check(potentialPair));",
                    "\t",
                    "\t\t\tpairList.add(potentialPair);",
                    "\t\t}",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t *  Private helper function that searches the NRList to ensure that",
                    "\t *  no two NetIDPair instances therein correspond to the same code.",
                    "\t *",
                    "\t *  @param potentialPair  A potential NetIDPair that may be added to the list.",
                    "\t *  @return True if the code of potentialPair isn't already found in",
                    "\t *          the NRList.",
                    "\t */",
                    "\tprivate boolean check(NetIDPair potentialPair){",
                    "\t\tboolean duplicate = false;",
                    "\t\tfor(int x = 0; x < pairList.size(); x++){",
                    "\t\t\tduplicate = pairList.get(x).getRandom()==potentialPair.getRandom();\t",
                    "\t\t\tif(duplicate) break;",
                    "\t\t}",
                    "\t\treturn duplicate;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t *  Returns the code corresponding to a given netID.",
                    "\t *  ",
                    "\t *  @param netID  The netID whose code is being searched.",
                    "\t * ",
                    "\t *  @return  The code of the netID argument if it is found or -1 otherwise.",
                    "\t */",
                    "\tpublic int getSecret(String netID)",
                    "\t{",
                    "\t\tfor(NetIDPair elem : pairList)",
                    "\t\t\tif (elem.equals(netID))",
                    "\t\t\t\treturn elem.getRandom();",
                    "\t\treturn -1;",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * Prints out the contents of this NRList separated by",
                    "\t * newlines.",
                    "\t */",
                    "\tpublic void printList() {",
                    "\t\tfor (int i = 0; i < pairList.size(); i++) {",
                    "\t\t\tSystem.out.println(pairList.get(i));",
                    "\t\t}",
                    "\t}",
                    "\t",
                    "\t/**",
                    "\t * @return an iterator to the start of this NRList.",
                    "\t */",
                    "\tpublic NRIterator iterator() { return new NRIterator(); }",
                    "\t",
                    "\t/**",
                    "\t * Iterator class for NRList. Allows sequential access of all",
                    "\t * elements in this container.",
                    "\t */",
                    "\tpublic class NRIterator implements Iterator<NetIDPair>{",
                    "\t\tprivate int curr;",
                    "\t\t",
                    "\t\tpublic NRIterator()      { curr = 0; }",
                    "\t\tpublic boolean hasNext() { return curr < pairList.size(); }",
                    "\t\tpublic NetIDPair next()  { return pairList.get(curr++); }",
                    "\t\tpublic void remove()     { throw new UnsupportedOperationException(); }",
                    "\t}",
                    "}",
                    ""
                ],
                "hidden": true
            },
            "output": {
                "state": {},
                "result": "com.twosigma.beaker.javash.bkr28670c17.NRList",
                "selectedType": "Text",
                "pluginName": "Java",
                "shellId": "28670c17-eed5-4f75-811e-b172fdbb2c75",
                "elapsedTime": 57
            },
            "evaluatorReader": true,
            "lineCount": 117,
            "initialization": true
        },
        {
            "id": "sectionBARdMF",
            "type": "section",
            "title": "FeebackEntry",
            "level": 3,
            "evaluatorReader": false,
            "collapsed": false
        },
        {
            "id": "codeZ97u4Z",
            "type": "code",
            "evaluator": "Java",
            "input": {
                "body": [
                    "import java.text.SimpleDateFormat;",
                    "import java.util.Date;",
                    "\t",
                    "/**",
                    "\t *  This class is a simple data structure that represents an entry from the CS125",
                    "\t *  lecture feedback app. It contains a pair of encoded NetIDs, a grade, two",
                    "\t *  feedback strings, and a date string.",
                    "\t *  @author CS125 Research",
                    "\t */",
                    "\tpublic final class FeedbackEntry{",
                    "\t\t",
                    "\t\tprivate boolean good = false;",
                    "\t\tprivate int grade = -1;",
                    "\t\tprivate int personID = -1;",
                    "\t\tprivate int partnerID = -1;",
                    "\t\tprivate String strengths;",
                    "\t\tprivate String weaknesses;",
                    "\t\tprivate Date date;",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * String constructor. Takes an unprocessed line from a CSV file and",
                    "\t\t * parses it as a valid FeedbackEntry using a passed-in NRList to",
                    "\t\t * verify NetIDs. The constructor exits early and marks the entry as",
                    "\t\t * bad if any NetIDs are missing or do not belong to any students in",
                    "\t\t * the NRList. [It also throws an exception if the data clearly",
                    "\t\t * cannot represent an entry made by a student. Useful for debugging.]",
                    "\t\t *",
                    "\t\t *  @param data  An unprocessed line to parse. Must be formatted in the",
                    "\t\t *               form \"netid1\", \"netid2\", \"5\", \"Strengths\", ",
                    "\t\t *               \"Weaknesses\", \"Date\";",
                    "\t\t *  @param map   A list of all netIDs of students in the class",
                    "\t\t *               and their corresponding codes.",
                    "\t\t */",
                    "\t\tpublic FeedbackEntry(String data, NRList map){",
                    "\t\t\tgood = true;",
                    "\t\t\tcheckCorruptData(data);",
                    "\t\t\tString[] separated = splitCommas(data);",
                    "\t\t\tfor (int i = 0; i < separated.length; ++i)",
                    "\t\t\t\tseparated[i] = process(separated[i]);",
                    "\t\t\tpersonID = map.getSecret(separated[0]);",
                    "\t\t\tpartnerID = map.getSecret(separated[1]);",
                    "\t\t\tgrade = Integer.parseInt(separated[2]);",
                    "\t\t\tif (personID == -1 || partnerID == -1 || grade > 10 || grade < 1 || ",
                    "\t\t\t    personID == partnerID){",
                    "\t\t\t\tgood = false;",
                    "\t\t\t}",
                    "\t\t\tstrengths = separated[3];",
                    "\t\t\tweaknesses = separated[4];",
                    "\t\t\ttry{",
                    "\t\t\t\tdate = new ",
                    "\t\t\t\t    SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\").parse(separated[5]);",
                    "\t\t\t}catch(Exception e){}",
                    "\t\t}",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * This merge constructor creates a FeedbackEntry whose parameters are",
                    "\t\t * all the same as those of the last element in the argument, except",
                    "\t\t * for the written feedback parameters. These parameters are formed",
                    "\t\t * from a processed concatenation of all elements in the argument.",
                    "\t\t * ",
                    "\t\t * @param duplicates An array of FeedbackEntries corresponding to the",
                    "\t\t *                   same lecture and having the same personID.",
                    "\t\t */",
                    "\t\tpublic FeedbackEntry(FeedbackEntry[] duplicates){",
                    "\t\t\tint last = duplicates.length - 1;",
                    "\t\t\tpersonID = duplicates[last].personID;",
                    "\t\t\tpartnerID = duplicates[last].partnerID;",
                    "\t\t\tgrade = duplicates[last].grade;",
                    "\t\t\tgood = duplicates[last].good;",
                    "\t\t\tif (duplicates.length == 1){",
                    "\t\t\t\tstrengths = duplicates[0].strengths;",
                    "\t\t\t\tweaknesses = duplicates[0].weaknesses;",
                    "\t\t\t\treturn;",
                    "\t\t\t}",
                    "\t\t\tStringBuilder strBuild = new StringBuilder();",
                    "\t\t\tStringBuilder weakBuild = new StringBuilder();",
                    "\t\t\tfor (FeedbackEntry elem : duplicates){",
                    "\t\t\t\tstrBuild.append('{' + elem.strengths + '}');",
                    "\t\t\t\tweakBuild.append('{' + elem.weaknesses + '}');",
                    "\t\t\t}",
                    "\t\t\tstrengths = strBuild.toString();",
                    "\t\t\tweaknesses = weakBuild.toString();",
                    "\t\t}",
                    "\t\t",
                    "\t\t/**",
                    "\t\t * Returns true if this entry is valid. This implies that both NetID ",
                    "\t\t * codes were entered and actually represent real students and that the ",
                    "\t\t * grade was between 1 and 10 and that the date was a valid date.",
                    "\t\t *",
                    "\t\t *  @return True for valid entries, false for invalid entries.",
                    "\t\t */",
                    "\t\tpublic boolean valid()        {return good;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return How well the student rated this lecture, from 1 to 10.",
                    "\t\t */",
                    "\t\tpublic int     getGrade()     {return grade;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The int code representing the netID of the first person.",
                    "\t\t */",
                    "\t\tpublic int     getPersonID()  {return personID;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The int code representing the netID of the second person.",
                    "\t\t */",
                    "\t\tpublic int     getPartnerID() {return partnerID;}",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The student's report on what he/she understood from lecture.",
                    "\t\t */",
                    "\t\tpublic String  getStrength()  { return strengths; }",
                    "",
                    "\t\t/**",
                    "\t\t *  @return The student's report on what he/she did not understand from ",
                    "\t\t *          lecture.",
                    "\t\t */",
                    "\t\tpublic String  getWeakness()  { return weaknesses; }",
                    "",
                    "\t\t/**",
                    "\t\t *  @return A copy of the date of this entry.",
                    "\t\t */",
                    "\t\tpublic Date    getDate()      { return new Date(date.getTime()); }",
                    "",
                    "\t\t/**",
                    "\t\t *  Method that indicates whether this entry has any written",
                    "\t\t *  feedback information at all.",
                    "\t\t *",
                    "\t\t *  @return True if either weaknesses or strengths is nonempty, false",
                    "\t\t *          otherwise.",
                    "\t\t */",
                    "\t\tpublic boolean hasFeedback(){",
                    "\t\t\treturn (strengths.length() > 0 || weaknesses.length() > 0);",
                    "\t\t}",
                    "",
                    "\t\t/**",
                    "\t\t *  Returns a simple but complete representation of this entry. Note",
                    "\t\t *  that invalid entries return \"INVALID ENTRY\". Not for file writing.",
                    "\t\t *",
                    "\t\t *  @return \"INVALID_ENTRY\" for invalid entries or a single-line ",
                    "\t\t * \t\t\trepresentation of all data members of this entry.",
                    "\t\t */",
                    "\t\tpublic String toString(){",
                    "\t\t\tString result = String.format(\"Student: %d Partner: %d Grade: %d\"",
                    "\t\t\t                  + \"Good: \\\"%s\\\" Bad: \\\"%s\\\" Date: %s\", ",
                    "\t\t\t                     personID, partnerID, grade,",
                    "\t\t\t                     strengths, weaknesses, date);",
                    "\t\t\treturn (!good ? \"INVALID ENTRY: \":\"\") + result;",
                    "\t\t}",
                    "\t\t",
                    "\t\t/**",
                    "\t\t *  Checks to see that a line passed into the constructor could possibly",
                    "\t\t *  represent an entry (valid or otherwise) made by a student and stored",
                    "\t\t *  in a CVS file. The method throws an IllegalArgumentException if the",
                    "\t\t *  line is invalid, namely if it doesn't have the right number of",
                    "\t\t *  elements or its elements are not surrounded with quotation marks.",
                    "\t\t *",
                    "\t\t *  @param line The line to be validated. ",
                    "\t\t */",
                    "\t\tprivate void checkCorruptData(String line){",
                    "\t\t\tSimpleDateFormat tst = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");",
                    "\t\t\ttry{",
                    "\t\t\t\tString[] separated = splitCommas(line);",
                    "\t\t\t\tDate tmp1 = tst.parse(separated[5]);",
                    "\t\t\t\tint tmp2 = Integer.parseInt(separated[2]);",
                    "\t\t\t}catch(Exception e){",
                    "\t\t\t\tthrow new IllegalArgumentException(line);",
                    "\t\t\t}",
                    "\t\t}",
                    "",
                    "\t\t/**",
                    "\t\t * Method that processes written feedback for better representation. ",
                    "\t\t * For example, should remove newlines and leading whitespaces.",
                    "\t\t *",
                    "\t\t * @param An unprocessed string of written feedback.",
                    "\t\t * @return A processed string of written feedback.",
                    "\t\t */",
                    "\t\tprivate String process(String unprocessed){",
                    "\t\t\tif (unprocessed.length() == 0)",
                    "\t\t\t\treturn unprocessed;",
                    "\t\t\tunprocessed = unprocessed.replace(\"\\n\", \" \"); //Removes newlines",
                    "\t\t\treturn unprocessed.trim();     //Removes trailing/leading whitespace",
                    "\t\t}",
                    "\t",
                    "",
                    "\t\t /**",
                    "\t\t  * Private helper method for constructor. Splits a String into a ",
                    "\t\t  * String[], splitting at (and getting rid of) commas ONLY IF those ",
                    "\t\t  * commas are not enclosed by quotes. Also converts double-double ",
                    "\t\t  * quotes into ordinary double quotes and implicitly throws an ",
                    "\t\t  * exception if the number of partitions is not exactly 6.",
                    "\t\t  *",
                    "\t\t  *  @params input The string to be parsed from a CVS file.",
                    "\t\t  *",
                    "\t\t  *  @return A String array containing the formatted contents of input, ",
                    "\t\t  *          split at commas iff they are enclosed by quotation marks.",
                    "\t\t  */",
                    "\t\tprivate static String[] splitCommas(String input)",
                    "\t\t{",
                    "\t\t    String[] partitions = new String[6];",
                    "\t\t    int partition = 0;",
                    "\t\t    StringBuilder build = new StringBuilder();",
                    "\t\t    boolean evenQuotes = true;",
                    "\t\t    boolean lastQuote = false;",
                    "\t\t    int i = 0;",
                    "\t\t    char current = '\\0';",
                    "\t\t    while (i < input.length()){",
                    "\t\t        while(i < input.length() && ",
                    "\t\t              (current = input.charAt(i++)) != ',' || !evenQuotes){",
                    "\t\t            if (current == '\\\"'){",
                    "\t\t                evenQuotes = !evenQuotes;",
                    "\t\t                if (lastQuote && !evenQuotes){",
                    "\t\t                    build.append(current);",
                    "\t\t                    lastQuote = false;",
                    "\t\t                    continue;",
                    "\t\t                }else",
                    "\t\t                    lastQuote = true;",
                    "\t\t            }else if (!evenQuotes){",
                    "\t\t                build.append(current);",
                    "\t\t                lastQuote = false;",
                    "\t\t            }",
                    "\t\t        }",
                    "\t\t        if (i == input.length() && input.charAt(i-1) != ',')",
                    "\t\t        \tbreak;",
                    "\t\t        partitions[partition++] = build.toString();",
                    "\t\t        build.setLength(0);",
                    "\t\t        lastQuote = false;",
                    "\t\t    }",
                    "\t\t    partitions[partition++] = build.toString();",
                    "\t\t    if (partition != 6)",
                    "\t\t    \tthrow new IllegalArgumentException();",
                    "\t\t    return partitions;",
                    "\t\t}",
                    "}",
                    ""
                ]
            },
            "output": {
                "state": {},
                "result": {
                    "type": "BeakerDisplay",
                    "innertype": "Error",
                    "object": [
                        "ERROR: java.lang.IllegalStateException: illegal start of expression",
                        "ption {",
                        "\t\tpublic fin"
                    ]
                },
                "selectedType": "BeakerDisplay",
                "pluginName": "Java",
                "shellId": "28670c17-eed5-4f75-811e-b172fdbb2c75",
                "elapsedTime": 59
            },
            "evaluatorReader": true,
            "lineCount": 235
        }
    ],
    "namespace": {}
}
